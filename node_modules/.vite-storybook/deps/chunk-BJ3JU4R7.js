import {
  require_synchronous_promise
} from "./chunk-BO3R2ZPC.js";
import {
  require_slash
} from "./chunk-V27W47CK.js";
import {
  require_mapValues
} from "./chunk-AE6N56OT.js";
import {
  require_pick
} from "./chunk-NEVMD4ST.js";
import {
  require_pickBy
} from "./chunk-NGQPZQN3.js";
import {
  require_isPlainObject
} from "./chunk-5JZSDNMO.js";
import {
  dedent,
  esm_default
} from "./chunk-DKITWJI6.js";
import {
  require_browser
} from "./chunk-2ZW4L6ZT.js";
import {
  createChannel
} from "./chunk-ZI7T7YNG.js";
import {
  require_lib
} from "./chunk-6JUMOWIJ.js";
import {
  scope
} from "./chunk-CWO6CHOE.js";
import {
  require_memoizerific
} from "./chunk-K2QDYCNL.js";
import {
  require_dist
} from "./chunk-4QHP5QJC.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@storybook/preview-api/node_modules/@storybook/channels/dist/index.mjs
var generateRandomId = () => Math.random().toString(16).slice(2);
var Channel = class {
  constructor({ transport, async = false } = {}) {
    this.sender = generateRandomId();
    this.events = {};
    this.data = {};
    this.transport = void 0;
    this.isAsync = async, transport && (this.transport = transport, this.transport.setHandler((event) => this.handleEvent(event)));
  }
  get hasTransport() {
    return !!this.transport;
  }
  addListener(eventName, listener) {
    this.events[eventName] = this.events[eventName] || [], this.events[eventName].push(listener);
  }
  emit(eventName, ...args) {
    let event = { type: eventName, args, from: this.sender }, options = {};
    args.length >= 1 && args[0] && args[0].options && (options = args[0].options);
    let handler = () => {
      this.transport && this.transport.send(event, options), this.handleEvent(event);
    };
    this.isAsync ? setImmediate(handler) : handler();
  }
  last(eventName) {
    return this.data[eventName];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(eventName) {
    let listeners = this.listeners(eventName);
    return listeners ? listeners.length : 0;
  }
  listeners(eventName) {
    return this.events[eventName] || void 0;
  }
  once(eventName, listener) {
    let onceListener = this.onceListener(eventName, listener);
    this.addListener(eventName, onceListener);
  }
  removeAllListeners(eventName) {
    eventName ? this.events[eventName] && delete this.events[eventName] : this.events = {};
  }
  removeListener(eventName, listener) {
    let listeners = this.listeners(eventName);
    listeners && (this.events[eventName] = listeners.filter((l) => l !== listener));
  }
  on(eventName, listener) {
    this.addListener(eventName, listener);
  }
  off(eventName, listener) {
    this.removeListener(eventName, listener);
  }
  handleEvent(event) {
    let listeners = this.listeners(event.type);
    listeners && listeners.length && listeners.forEach((fn) => {
      fn.apply(event, event.args);
    }), this.data[event.type] = event.args;
  }
  onceListener(eventName, listener) {
    let onceListener = (...args) => (this.removeListener(eventName, onceListener), listener(...args));
    return onceListener;
  }
};

// node_modules/@storybook/preview-api/node_modules/@storybook/client-logger/dist/index.mjs
var { LOGLEVEL } = scope;
var levels = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 };
var currentLogLevelString = LOGLEVEL;
var currentLogLevelNumber = levels[currentLogLevelString] || levels.info;
var logger = { trace: (message, ...rest) => {
  currentLogLevelNumber <= levels.trace && console.trace(message, ...rest);
}, debug: (message, ...rest) => {
  currentLogLevelNumber <= levels.debug && console.debug(message, ...rest);
}, info: (message, ...rest) => {
  currentLogLevelNumber <= levels.info && console.info(message, ...rest);
}, warn: (message, ...rest) => {
  currentLogLevelNumber <= levels.warn && console.warn(message, ...rest);
}, error: (message, ...rest) => {
  currentLogLevelNumber <= levels.error && console.error(message, ...rest);
}, log: (message, ...rest) => {
  currentLogLevelNumber < levels.silent && console.log(message, ...rest);
} };
var logged = /* @__PURE__ */ new Set();
var once = (type) => (message, ...rest) => {
  if (!logged.has(message))
    return logged.add(message), logger[type](message, ...rest);
};
once.clear = () => logged.clear();
once.trace = once("trace");
once.debug = once("debug");
once.info = once("info");
once.warn = once("warn");
once.error = once("error");
once.log = once("log");
var deprecate = once("warn");
var pretty = (type) => (...args) => {
  let argArray = [];
  if (args.length) {
    let startTagRe = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, endTagRe = /<\/span>/gi, reResultArray;
    for (argArray.push(args[0].replace(startTagRe, "%c").replace(endTagRe, "%c")); reResultArray = startTagRe.exec(args[0]); )
      argArray.push(reResultArray[2]), argArray.push("");
    for (let j = 1; j < args.length; j++)
      argArray.push(args[j]);
  }
  logger[type].apply(logger, argArray);
};
pretty.trace = pretty("trace");
pretty.debug = pretty("debug");
pretty.info = pretty("info");
pretty.warn = pretty("warn");
pretty.error = pretty("error");

// node_modules/@storybook/preview-api/node_modules/@storybook/core-events/dist/index.mjs
var events = ((events2) => (events2.CHANNEL_CREATED = "channelCreated", events2.CONFIG_ERROR = "configError", events2.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", events2.STORY_SPECIFIED = "storySpecified", events2.SET_CONFIG = "setConfig", events2.SET_STORIES = "setStories", events2.SET_INDEX = "setIndex", events2.SET_CURRENT_STORY = "setCurrentStory", events2.CURRENT_STORY_WAS_SET = "currentStoryWasSet", events2.FORCE_RE_RENDER = "forceReRender", events2.FORCE_REMOUNT = "forceRemount", events2.PRELOAD_ENTRIES = "preloadStories", events2.STORY_PREPARED = "storyPrepared", events2.STORY_CHANGED = "storyChanged", events2.STORY_UNCHANGED = "storyUnchanged", events2.STORY_RENDERED = "storyRendered", events2.STORY_MISSING = "storyMissing", events2.STORY_ERRORED = "storyErrored", events2.STORY_THREW_EXCEPTION = "storyThrewException", events2.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", events2.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", events2.UPDATE_STORY_ARGS = "updateStoryArgs", events2.STORY_ARGS_UPDATED = "storyArgsUpdated", events2.RESET_STORY_ARGS = "resetStoryArgs", events2.SET_GLOBALS = "setGlobals", events2.UPDATE_GLOBALS = "updateGlobals", events2.GLOBALS_UPDATED = "globalsUpdated", events2.REGISTER_SUBSCRIPTION = "registerSubscription", events2.PREVIEW_KEYDOWN = "previewKeydown", events2.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", events2.SELECT_STORY = "selectStory", events2.STORIES_COLLAPSE_ALL = "storiesCollapseAll", events2.STORIES_EXPAND_ALL = "storiesExpandAll", events2.DOCS_RENDERED = "docsRendered", events2.SHARED_STATE_CHANGED = "sharedStateChanged", events2.SHARED_STATE_SET = "sharedStateSet", events2.NAVIGATE_URL = "navigateUrl", events2.UPDATE_QUERY_PARAMS = "updateQueryParams", events2))(events || {});
var { CHANNEL_CREATED, CONFIG_ERROR, CURRENT_STORY_WAS_SET, DOCS_RENDERED, FORCE_RE_RENDER, FORCE_REMOUNT, GLOBALS_UPDATED, NAVIGATE_URL, PLAY_FUNCTION_THREW_EXCEPTION, PRELOAD_ENTRIES, PREVIEW_BUILDER_PROGRESS, PREVIEW_KEYDOWN, REGISTER_SUBSCRIPTION, RESET_STORY_ARGS, SELECT_STORY, SET_CONFIG, SET_CURRENT_STORY, SET_GLOBALS, SET_INDEX, SET_STORIES, SHARED_STATE_CHANGED, SHARED_STATE_SET, STORIES_COLLAPSE_ALL, STORIES_EXPAND_ALL, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_INDEX_INVALIDATED, STORY_MISSING, STORY_PREPARED, STORY_RENDER_PHASE_CHANGED, STORY_RENDERED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, UPDATE_GLOBALS, UPDATE_QUERY_PARAMS, UPDATE_STORY_ARGS } = events;
var IGNORED_EXCEPTION = new Error("ignoredException");

// node_modules/@storybook/preview-api/dist/chunk-RTGEOU4B.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
function mockChannel() {
  let transport = { setHandler: () => {
  }, send: () => {
  } };
  return new Channel({ transport });
}
var AddonStore = class {
  constructor() {
    this.getChannel = () => {
      if (!this.channel) {
        let channel = mockChannel();
        return this.setChannel(channel), channel;
      }
      return this.channel;
    };
    this.getServerChannel = () => {
      if (!this.serverChannel)
        throw new Error("Accessing non-existent serverChannel");
      return this.serverChannel;
    };
    this.ready = () => this.promise;
    this.hasChannel = () => !!this.channel;
    this.hasServerChannel = () => !!this.serverChannel;
    this.setChannel = (channel) => {
      this.channel = channel, this.resolve();
    };
    this.setServerChannel = (channel) => {
      this.serverChannel = channel;
    };
    this.promise = new Promise((res) => {
      this.resolve = () => res(this.getChannel());
    });
  }
};
var KEY = "__STORYBOOK_ADDONS_PREVIEW";
function getAddonsStore() {
  return scope[KEY] || (scope[KEY] = new AddonStore()), scope[KEY];
}
var addons = getAddonsStore();
var HooksContext = class {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = (storyId) => {
      var _a;
      storyId === ((_a = this.currentContext) == null ? void 0 : _a.id) && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    };
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = this.mountedDecorators, this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((effect) => {
      effect.destroy && effect.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let hook = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, hook;
  }
  triggerEffects() {
    this.prevEffects.forEach((effect) => {
      !this.currentEffects.includes(effect) && effect.destroy && effect.destroy();
    }), this.currentEffects.forEach((effect) => {
      this.prevEffects.includes(effect) || (effect.destroy = effect.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), addons.getChannel().on(STORY_RENDERED, this.renderListener);
  }
  removeRenderListeners() {
    addons.getChannel().removeListener(STORY_RENDERED, this.renderListener);
  }
};
function hookify(fn) {
  return (...args) => {
    let { hooks } = typeof args[0] == "function" ? args[1] : args[0], prevPhase = hooks.currentPhase, prevHooks = hooks.currentHooks, prevNextHookIndex = hooks.nextHookIndex, prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn.name, hooks.prevMountedDecorators.has(fn) ? (hooks.currentPhase = "UPDATE", hooks.currentHooks = hooks.hookListsMap.get(fn) || []) : (hooks.currentPhase = "MOUNT", hooks.currentHooks = [], hooks.hookListsMap.set(fn, hooks.currentHooks), hooks.prevMountedDecorators.add(fn)), hooks.nextHookIndex = 0;
    let prevContext = scope.STORYBOOK_HOOKS_CONTEXT;
    scope.STORYBOOK_HOOKS_CONTEXT = hooks;
    let result = fn(...args);
    if (scope.STORYBOOK_HOOKS_CONTEXT = prevContext, hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null)
      throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    return hooks.currentPhase = prevPhase, hooks.currentHooks = prevHooks, hooks.nextHookIndex = prevNextHookIndex, hooks.currentDecoratorName = prevDecoratorName, result;
  };
}
var numberOfRenders = 0;
var RENDER_LIMIT = 25;
var applyHooks = (applyDecorators) => (storyFn, decorators) => {
  let decorated = applyDecorators(hookify(storyFn), decorators.map((decorator) => hookify(decorator)));
  return (context) => {
    let { hooks } = context;
    hooks.prevMountedDecorators = hooks.mountedDecorators, hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators]), hooks.currentContext = context, hooks.hasUpdates = false;
    let result = decorated(context);
    for (numberOfRenders = 1; hooks.hasUpdates; )
      if (hooks.hasUpdates = false, hooks.currentEffects = [], result = decorated(context), numberOfRenders += 1, numberOfRenders > RENDER_LIMIT)
        throw new Error("Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.");
    return hooks.addRenderListeners(), result;
  };
};

// node_modules/@storybook/preview-api/dist/chunk-QTGABOHS.mjs
var import_memoizerific = __toESM(require_memoizerific(), 1);
var import_mapValues = __toESM(require_mapValues(), 1);
var import_pick = __toESM(require_pick(), 1);
var import_synchronous_promise = __toESM(require_synchronous_promise(), 1);
var import_memoizerific2 = __toESM(require_memoizerific(), 1);

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/@storybook/preview-api/dist/chunk-QTGABOHS.mjs
var import_isPlainObject = __toESM(require_isPlainObject(), 1);
var import_mapValues2 = __toESM(require_mapValues(), 1);
var import_csf = __toESM(require_dist(), 1);
var import_util_deprecate = __toESM(require_browser(), 1);
var import_csf2 = __toESM(require_dist(), 1);
var import_csf3 = __toESM(require_dist(), 1);
var import_csf4 = __toESM(require_dist(), 1);
var import_isPlainObject2 = __toESM(require_isPlainObject(), 1);
var import_mapValues3 = __toESM(require_mapValues(), 1);
var import_mapValues4 = __toESM(require_mapValues(), 1);
var import_pickBy = __toESM(require_pickBy(), 1);
var import_csf5 = __toESM(require_dist(), 1);
var import_slash = __toESM(require_slash(), 1);
var getImportPathMap = (0, import_memoizerific2.default)(1)((entries) => Object.values(entries).reduce((acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc), {}));
var StoryIndexStore = class {
  constructor({ entries } = { v: 4, entries: {} }) {
    this.entries = entries;
  }
  entryFromSpecifier(specifier) {
    let entries = Object.values(this.entries);
    if (specifier === "*")
      return entries[0];
    if (typeof specifier == "string")
      return this.entries[specifier] ? this.entries[specifier] : entries.find((entry) => entry.id.startsWith(specifier));
    let { name, title } = specifier;
    return entries.find((entry) => entry.name === name && entry.title === title);
  }
  storyIdToEntry(storyId) {
    let storyEntry = this.entries[storyId];
    if (!storyEntry)
      throw new Error(dedent`Couldn't find story matching '${storyId}' after HMR.
      - Did you remove it from your CSF file?
      - Are you sure a story with that id exists?
      - Please check your entries field of your main.js config.
      - Also check the browser console and terminal for error messages.`);
    return storyEntry;
  }
  importPathToEntry(importPath) {
    return getImportPathMap(this.entries)[importPath];
  }
};
var INCOMPATIBLE = Symbol("incompatible");
var map = (arg, argType) => {
  let type = argType.type;
  if (arg == null || !type || argType.mapping)
    return arg;
  switch (type.name) {
    case "string":
      return String(arg);
    case "enum":
      return arg;
    case "number":
      return Number(arg);
    case "boolean":
      return arg === "true";
    case "array":
      return !type.value || !Array.isArray(arg) ? INCOMPATIBLE : arg.reduce((acc, item, index) => {
        let mapped = map(item, { type: type.value });
        return mapped !== INCOMPATIBLE && (acc[index] = mapped), acc;
      }, new Array(arg.length));
    case "object":
      return typeof arg == "string" || typeof arg == "number" ? arg : !type.value || typeof arg != "object" ? INCOMPATIBLE : Object.entries(arg).reduce((acc, [key, val]) => {
        let mapped = map(val, { type: type.value[key] });
        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
      }, {});
    default:
      return INCOMPATIBLE;
  }
};
var mapArgsToTypes = (args, argTypes) => Object.entries(args).reduce((acc, [key, value]) => {
  if (!argTypes[key])
    return acc;
  let mapped = map(value, argTypes[key]);
  return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
}, {});
var combineArgs = (value, update) => Array.isArray(value) && Array.isArray(update) ? update.reduce((acc, upd, index) => (acc[index] = combineArgs(value[index], update[index]), acc), [...value]).filter((v) => v !== void 0) : !(0, import_isPlainObject.default)(value) || !(0, import_isPlainObject.default)(update) ? update : Object.keys({ ...value, ...update }).reduce((acc, key) => {
  if (key in update) {
    let combined = combineArgs(value[key], update[key]);
    combined !== void 0 && (acc[key] = combined);
  } else
    acc[key] = value[key];
  return acc;
}, {});
var validateOptions = (args, argTypes) => Object.entries(argTypes).reduce((acc, [key, { options }]) => {
  function allowArg() {
    return key in args && (acc[key] = args[key]), acc;
  }
  if (!options)
    return allowArg();
  if (!Array.isArray(options))
    return once.error(dedent`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/react/api/argtypes
      `), allowArg();
  if (options.some((opt) => opt && ["object", "function"].includes(typeof opt)))
    return once.error(dedent`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
      `), allowArg();
  let isArray = Array.isArray(args[key]), invalidIndex = isArray && args[key].findIndex((val) => !options.includes(val)), isValidArray = isArray && invalidIndex === -1;
  if (args[key] === void 0 || options.includes(args[key]) || isValidArray)
    return allowArg();
  let field = isArray ? `${key}[${invalidIndex}]` : key, supportedOptions = options.map((opt) => typeof opt == "string" ? `'${opt}'` : String(opt)).join(", ");
  return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`), acc;
}, {});
var DEEPLY_EQUAL = Symbol("Deeply equal");
var deepDiff = (value, update) => {
  if (typeof value != typeof update)
    return update;
  if (dequal(value, update))
    return DEEPLY_EQUAL;
  if (Array.isArray(value) && Array.isArray(update)) {
    let res = update.reduce((acc, upd, index) => {
      let diff = deepDiff(value[index], upd);
      return diff !== DEEPLY_EQUAL && (acc[index] = diff), acc;
    }, new Array(update.length));
    return update.length >= value.length ? res : res.concat(new Array(value.length - update.length).fill(void 0));
  }
  return (0, import_isPlainObject.default)(value) && (0, import_isPlainObject.default)(update) ? Object.keys({ ...value, ...update }).reduce((acc, key) => {
    let diff = deepDiff(value == null ? void 0 : value[key], update == null ? void 0 : update[key]);
    return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff });
  }, {}) : update;
};
var UNTARGETED = "UNTARGETED";
function groupArgsByTarget({ args, argTypes }) {
  let groupedArgs = {};
  return Object.entries(args).forEach(([name, value]) => {
    let { target = UNTARGETED } = argTypes[name] || {};
    groupedArgs[target] = groupedArgs[target] || {}, groupedArgs[target][name] = value;
  }), groupedArgs;
}
function deleteUndefined(obj) {
  return Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]), obj;
}
var ArgsStore = class {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(storyId) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    return this.argsByStoryId[storyId];
  }
  setInitial(story) {
    if (!this.initialArgsByStoryId[story.id])
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs;
    else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
      let delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs, delta !== DEEPLY_EQUAL && this.updateFromDelta(story, delta);
    }
  }
  updateFromDelta(story, delta) {
    let validatedDelta = validateOptions(delta, story.argTypes);
    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
  }
  updateFromPersisted(story, persisted) {
    let mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
    return this.updateFromDelta(story, mappedPersisted);
  }
  update(storyId, argsUpdate) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    this.argsByStoryId[storyId] = deleteUndefined({ ...this.argsByStoryId[storyId], ...argsUpdate });
  }
};
var getValuesFromArgTypes = (argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => (typeof defaultValue < "u" && (acc[arg] = defaultValue), acc), {});
var GlobalsStore = class {
  constructor({ globals = {}, globalTypes = {} }) {
    this.set({ globals, globalTypes });
  }
  set({ globals = {}, globalTypes = {} }) {
    let delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
    let defaultGlobals = getValuesFromArgTypes(globalTypes);
    this.initialGlobals = { ...defaultGlobals, ...globals }, this.globals = this.initialGlobals, delta && delta !== DEEPLY_EQUAL && this.updateFromPersisted(delta);
  }
  filterAllowedGlobals(globals) {
    return Object.entries(globals).reduce((acc, [key, value]) => (this.allowedGlobalNames.has(key) ? acc[key] = value : logger.warn(`Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`), acc), {});
  }
  updateFromPersisted(persisted) {
    let allowedUrlGlobals = this.filterAllowedGlobals(persisted);
    this.globals = { ...this.globals, ...allowedUrlGlobals };
  }
  get() {
    return this.globals;
  }
  update(newGlobals) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
  }
};
var normalizeType = (type) => typeof type == "string" ? { name: type } : type;
var normalizeControl = (control) => typeof control == "string" ? { type: control } : control;
var normalizeInputType = (inputType, key) => {
  let { type, control, ...rest } = inputType, normalized = { name: key, ...rest };
  return type && (normalized.type = normalizeType(type)), control ? normalized.control = normalizeControl(control) : control === false && (normalized.control = { disable: true }), normalized;
};
var normalizeInputTypes = (inputTypes) => (0, import_mapValues2.default)(inputTypes, normalizeInputType);
var deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
var deprecatedStoryAnnotationWarning = (0, import_util_deprecate.default)(() => {
}, deprecatedStoryAnnotation);
function normalizeStory(key, storyAnnotations, meta) {
  let storyObject = storyAnnotations, userStoryFn = typeof storyAnnotations == "function" ? storyAnnotations : null, { story } = storyObject;
  story && (logger.debug("deprecated story", story), deprecatedStoryAnnotationWarning());
  let exportName = (0, import_csf.storyNameFromExport)(key), name = typeof storyObject != "function" && storyObject.name || storyObject.storyName || (story == null ? void 0 : story.name) || exportName, decorators = [...storyObject.decorators || [], ...(story == null ? void 0 : story.decorators) || []], parameters = { ...story == null ? void 0 : story.parameters, ...storyObject.parameters }, args = { ...story == null ? void 0 : story.args, ...storyObject.args }, argTypes = { ...story == null ? void 0 : story.argTypes, ...storyObject.argTypes }, loaders = [...storyObject.loaders || [], ...(story == null ? void 0 : story.loaders) || []], { render, play, tags = [] } = storyObject, id = parameters.__id || (0, import_csf.toId)(meta.id, exportName);
  return { moduleExport: storyAnnotations, id, name, tags, decorators, parameters, args, argTypes: normalizeInputTypes(argTypes), loaders, ...render && { render }, ...userStoryFn && { userStoryFn }, ...play && { play } };
}
function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
  let { id, argTypes } = defaultExport;
  return { id: (0, import_csf3.sanitize)(id || title), ...defaultExport, title, ...argTypes && { argTypes: normalizeInputTypes(argTypes) }, parameters: { fileName: importPath, ...defaultExport.parameters } };
}
var checkGlobals = (parameters) => {
  let { globals, globalTypes } = parameters;
  (globals || globalTypes) && logger.error("Global args/argTypes can only be set globally", JSON.stringify({ globals, globalTypes }));
};
var checkStorySort = (parameters) => {
  let { options } = parameters;
  (options == null ? void 0 : options.storySort) && logger.error("The storySort option parameter can only be set globally");
};
var checkDisallowedParameters = (parameters) => {
  parameters && (checkGlobals(parameters), checkStorySort(parameters));
};
var checkSubcomponents = (meta) => {
  meta.subcomponents && deprecate(esm_default`The \`subcomponents\` annotation is deprecated. 
    
      Please refer to the migration guide: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#argstable-block'
    `);
};
function processCSFFile(moduleExports, importPath, title) {
  let { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports, meta = normalizeComponentAnnotations(defaultExport, title, importPath);
  checkDisallowedParameters(meta.parameters), checkSubcomponents(meta);
  let csfFile = { meta, stories: {}, moduleExports };
  return Object.keys(namedExports).forEach((key) => {
    if ((0, import_csf2.isExportStory)(key, meta)) {
      let storyMeta = normalizeStory(key, namedExports[key], meta);
      checkDisallowedParameters(storyMeta.parameters), csfFile.stories[storyMeta.id] = storyMeta;
    }
  }), csfFile;
}
var combineParameters = (...parameterSets) => {
  let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters) => (Object.entries(parameters).forEach(([key, value]) => {
    let existing = acc[key];
    Array.isArray(value) || typeof existing > "u" ? acc[key] = value : (0, import_isPlainObject2.default)(value) && (0, import_isPlainObject2.default)(existing) ? mergeKeys[key] = true : typeof value < "u" && (acc[key] = value);
  }), acc), {});
  return Object.keys(mergeKeys).forEach((key) => {
    let mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key]).filter((value) => typeof value < "u");
    mergeValues.every((value) => (0, import_isPlainObject2.default)(value)) ? combined[key] = combineParameters(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];
  }), combined;
};
function decorateStory(storyFn, decorator, bindWithContext) {
  let boundStoryFunction = bindWithContext(storyFn);
  return (context) => decorator(boundStoryFunction, context);
}
function sanitizeStoryContextUpdate({ componentId, title, kind, id, name, story, parameters, initialArgs, argTypes, ...update } = {}) {
  return update;
}
function defaultDecorateStory(storyFn, decorators) {
  let contextStore = {}, bindWithContext = (decoratedStoryFn) => (update) => {
    if (!contextStore.value)
      throw new Error("Decorated function called without init");
    return contextStore.value = { ...contextStore.value, ...sanitizeStoryContextUpdate(update) }, decoratedStoryFn(contextStore.value);
  }, decoratedWithContextStore = decorators.reduce((story, decorator) => decorateStory(story, decorator, bindWithContext), storyFn);
  return (context) => (contextStore.value = context, decoratedWithContextStore(context));
}
function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
  let { moduleExport, id, name } = storyAnnotations || {}, partialAnnotations = preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations), loaders = [...projectAnnotations.loaders || [], ...componentAnnotations.loaders || [], ...(storyAnnotations == null ? void 0 : storyAnnotations.loaders) || []], applyLoaders = async (context) => {
    let loadResults = await Promise.all(loaders.map((loader) => loader(context))), loaded = Object.assign({}, ...loadResults);
    return { ...context, loaded };
  }, undecoratedStoryFn = (context) => {
    let { passArgsFirst: renderTimePassArgsFirst = true } = context.parameters;
    return renderTimePassArgsFirst ? render(context.args, context) : render(context);
  }, { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations, decorators = [...(storyAnnotations == null ? void 0 : storyAnnotations.decorators) || [], ...componentAnnotations.decorators || [], ...projectAnnotations.decorators || []], render = (storyAnnotations == null ? void 0 : storyAnnotations.userStoryFn) || (storyAnnotations == null ? void 0 : storyAnnotations.render) || componentAnnotations.render || projectAnnotations.render;
  if (!render)
    throw new Error(`No render function available for storyId '${id}'`);
  let decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators), unboundStoryFn = (context) => decoratedStoryFn(context), prepareContext = (context) => {
    var _a;
    let finalContext = context;
    if ((_a = scope.FEATURES) == null ? void 0 : _a.argTypeTargetsV7) {
      let argsByTarget = groupArgsByTarget(context);
      finalContext = { ...context, allArgs: context.args, argsByTarget, args: argsByTarget[UNTARGETED] || {} };
    }
    let mappedArgs = Object.entries(finalContext.args).reduce((acc, [key, val]) => {
      var _a2;
      let mapping = (_a2 = finalContext.argTypes[key]) == null ? void 0 : _a2.mapping;
      return acc[key] = mapping && val in mapping ? mapping[val] : val, acc;
    }, {}), includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
      let argType = finalContext.argTypes[key] || {};
      return (0, import_csf4.includeConditionalArg)(argType, mappedArgs, finalContext.globals) && (acc[key] = val), acc;
    }, {});
    return { ...finalContext, args: includedArgs };
  }, play = (storyAnnotations == null ? void 0 : storyAnnotations.play) || componentAnnotations.play;
  return { ...partialAnnotations, moduleExport, id, name, story: name, originalStoryFn: render, undecoratedStoryFn, unboundStoryFn, applyLoaders, playFunction: play && (async (storyContext) => {
    let playFunctionContext = { ...storyContext, step: (label, play2) => runStep(label, play2, playFunctionContext) };
    return play(playFunctionContext);
  }), prepareContext };
}
function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
  return { ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations), moduleExport };
}
function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
  var _a;
  let id = (storyAnnotations == null ? void 0 : storyAnnotations.id) || componentAnnotations.id, tags = [...(storyAnnotations == null ? void 0 : storyAnnotations.tags) || componentAnnotations.tags || [], "story"], parameters = combineParameters(projectAnnotations.parameters, componentAnnotations.parameters, storyAnnotations == null ? void 0 : storyAnnotations.parameters), { argTypesEnhancers = [], argsEnhancers = [] } = projectAnnotations, render = (storyAnnotations == null ? void 0 : storyAnnotations.userStoryFn) || (storyAnnotations == null ? void 0 : storyAnnotations.render) || componentAnnotations.render || projectAnnotations.render;
  if (!render)
    throw new Error(`No render function available for id '${id}'`);
  let passedArgTypes = combineParameters(projectAnnotations.argTypes, componentAnnotations.argTypes, storyAnnotations == null ? void 0 : storyAnnotations.argTypes), { passArgsFirst = true } = parameters;
  parameters.__isArgsStory = passArgsFirst && render.length > 0;
  let passedArgs = { ...projectAnnotations.args, ...componentAnnotations.args, ...storyAnnotations == null ? void 0 : storyAnnotations.args }, contextForEnhancers = { componentId: componentAnnotations.id, title: componentAnnotations.title, kind: componentAnnotations.title, id: (storyAnnotations == null ? void 0 : storyAnnotations.id) || componentAnnotations.id, name: (storyAnnotations == null ? void 0 : storyAnnotations.name) || "__meta", story: (storyAnnotations == null ? void 0 : storyAnnotations.name) || "__meta", component: componentAnnotations.component, subcomponents: componentAnnotations.subcomponents, tags, parameters, initialArgs: passedArgs, argTypes: passedArgTypes };
  contextForEnhancers.argTypes = argTypesEnhancers.reduce((accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }), contextForEnhancers.argTypes);
  let initialArgsBeforeEnhancers = { ...passedArgs };
  contextForEnhancers.initialArgs = argsEnhancers.reduce((accumulatedArgs, enhancer) => ({ ...accumulatedArgs, ...enhancer({ ...contextForEnhancers, initialArgs: accumulatedArgs }) }), initialArgsBeforeEnhancers), ((_a = scope.FEATURES) == null ? void 0 : _a.breakingChangesV7) || (contextForEnhancers.parameters = { ...contextForEnhancers.parameters, __id: id, globals: projectAnnotations.globals, globalTypes: projectAnnotations.globalTypes, args: contextForEnhancers.initialArgs, argTypes: contextForEnhancers.argTypes });
  let { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;
  return withoutStoryIdentifiers;
}
var inferType = (value, name, visited) => {
  let type = typeof value;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: type };
    default:
      break;
  }
  return value ? visited.has(value) ? (logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (visited.add(value), Array.isArray(value) ? { name: "array", value: value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: "other", value: "unknown" } } : { name: "object", value: (0, import_mapValues3.default)(value, (field) => inferType(field, name, new Set(visited))) }) : { name: "object", value: {} };
};
var inferArgTypes = (context) => {
  let { id, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = (0, import_mapValues3.default)(initialArgs, (arg, key) => ({ name: key, type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set()) })), userArgTypesNames = (0, import_mapValues3.default)(userArgTypes, (argType, key) => ({ name: key }));
  return combineParameters(argTypes, userArgTypesNames, userArgTypes);
};
inferArgTypes.secondPass = true;
var matches = (name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor);
var filterArgTypes = (argTypes, include, exclude) => !include && !exclude ? argTypes : argTypes && (0, import_pickBy.default)(argTypes, (argType, key) => {
  let name = argType.name || key;
  return (!include || matches(name, include)) && (!exclude || !matches(name, exclude));
});
var inferControl = (argType, name, matchers) => {
  let { type, options } = argType;
  if (type) {
    if (matchers.color && matchers.color.test(name)) {
      let controlType = type.name;
      if (controlType === "string")
        return { control: { type: "color" } };
      controlType !== "enum" && logger.warn(`Addon controls: Control of type color only supports string, received "${controlType}" instead`);
    }
    if (matchers.date && matchers.date.test(name))
      return { control: { type: "date" } };
    switch (type.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value } = type;
        return { control: { type: (value == null ? void 0 : value.length) <= 5 ? "radio" : "select" }, options: value };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: options ? "select" : "object" } };
    }
  }
};
var inferControls = (context) => {
  let { argTypes, parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} } } = context;
  if (!__isArgsStory)
    return argTypes;
  let filteredArgTypes = filterArgTypes(argTypes, include, exclude), withControls = (0, import_mapValues4.default)(filteredArgTypes, (argType, name) => (argType == null ? void 0 : argType.type) && inferControl(argType, name, matchers));
  return combineParameters(withControls, filteredArgTypes);
};
inferControls.secondPass = true;
function normalizeProjectAnnotations({ argTypes, globalTypes, argTypesEnhancers, ...annotations }) {
  return { ...argTypes && { argTypes: normalizeInputTypes(argTypes) }, ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) }, argTypesEnhancers: [...argTypesEnhancers || [], inferArgTypes, inferControls], ...annotations };
}
function composeStepRunners(stepRunners) {
  return async (label, play, playContext) => {
    await stepRunners.reduceRight((innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext), async () => play(playContext))();
  };
}
function getField(moduleExportList, field) {
  return moduleExportList.map((xs) => xs[field]).filter(Boolean);
}
function getArrayField(moduleExportList, field) {
  return getField(moduleExportList, field).reduce((a, b) => [...a, ...b], []);
}
function getObjectField(moduleExportList, field) {
  return Object.assign({}, ...getField(moduleExportList, field));
}
function getSingletonField(moduleExportList, field) {
  return getField(moduleExportList, field).pop();
}
function composeConfigs(moduleExportList) {
  let allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers"), stepRunners = getField(moduleExportList, "runStep");
  return { parameters: combineParameters(...getField(moduleExportList, "parameters")), decorators: getArrayField(moduleExportList, "decorators"), args: getObjectField(moduleExportList, "args"), argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"), argTypes: getObjectField(moduleExportList, "argTypes"), argTypesEnhancers: [...allArgTypeEnhancers.filter((e) => !e.secondPass), ...allArgTypeEnhancers.filter((e) => e.secondPass)], globals: getObjectField(moduleExportList, "globals"), globalTypes: getObjectField(moduleExportList, "globalTypes"), loaders: getArrayField(moduleExportList, "loaders"), render: getSingletonField(moduleExportList, "render"), renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"), renderToDOM: getSingletonField(moduleExportList, "renderToDOM"), applyDecorators: getSingletonField(moduleExportList, "applyDecorators"), runStep: composeStepRunners(stepRunners) };
}
var CSF_CACHE_SIZE = 1e3;
var STORY_CACHE_SIZE = 1e4;
var EXTRACT_BATCH_SIZE = 20;
var StoryStore = class {
  constructor() {
    this.getStoriesJsonData = () => {
      let { storyIndex } = this;
      if (!storyIndex)
        throw new Error("getStoriesJsonData called before initialization");
      let value = this.getSetStoriesPayload(), allowedParameters = ["fileName", "docsOnly", "framework", "__id", "__isArgsStory"];
      return { v: 3, stories: (0, import_mapValues.default)(value.stories, (story) => {
        let { importPath } = storyIndex.entries[story.id];
        return { ...(0, import_pick.default)(story, ["id", "name", "title"]), importPath, kind: story.title, story: story.name, parameters: { ...(0, import_pick.default)(story.parameters, allowedParameters), fileName: importPath } };
      }) };
    };
    this.args = new ArgsStore(), this.hooks = {}, this.processCSFFileWithCache = (0, import_memoizerific.default)(CSF_CACHE_SIZE)(processCSFFile), this.prepareStoryWithCache = (0, import_memoizerific.default)(STORY_CACHE_SIZE)(prepareStory), this.initializationPromise = new import_synchronous_promise.SynchronousPromise((resolve) => {
      this.resolveInitializationPromise = resolve;
    });
  }
  setProjectAnnotations(projectAnnotations) {
    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
    let { globals, globalTypes } = projectAnnotations;
    this.globals ? this.globals.set({ globals, globalTypes }) : this.globals = new GlobalsStore({ globals, globalTypes });
  }
  initialize({ storyIndex, importFn, cache = false }) {
    return this.storyIndex = new StoryIndexStore(storyIndex), this.importFn = importFn, this.resolveInitializationPromise(), cache ? this.cacheAllCSFFiles() : import_synchronous_promise.SynchronousPromise.resolve();
  }
  async onStoriesChanged({ importFn, storyIndex }) {
    await this.initializationPromise, importFn && (this.importFn = importFn), storyIndex && (this.storyIndex.entries = storyIndex.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  async storyIdToEntry(storyId) {
    return await this.initializationPromise, this.storyIndex.storyIdToEntry(storyId);
  }
  loadCSFFileByStoryId(storyId) {
    if (!this.storyIndex || !this.importFn)
      throw new Error("loadCSFFileByStoryId called before initialization");
    let { importPath, title } = this.storyIndex.storyIdToEntry(storyId);
    return this.importFn(importPath).then((moduleExports) => this.processCSFFileWithCache(moduleExports, importPath, title));
  }
  loadAllCSFFiles({ batchSize = EXTRACT_BATCH_SIZE } = {}) {
    if (!this.storyIndex)
      throw new Error("loadAllCSFFiles called before initialization");
    let importPaths = Object.entries(this.storyIndex.entries).map(([storyId, { importPath }]) => [importPath, storyId]), loadInBatches = (remainingImportPaths) => {
      if (remainingImportPaths.length === 0)
        return import_synchronous_promise.SynchronousPromise.resolve([]);
      let csfFilePromiseList = remainingImportPaths.slice(0, batchSize).map(([importPath, storyId]) => this.loadCSFFileByStoryId(storyId).then((csfFile) => ({ importPath, csfFile })));
      return import_synchronous_promise.SynchronousPromise.all(csfFilePromiseList).then((firstResults) => loadInBatches(remainingImportPaths.slice(batchSize)).then((restResults) => firstResults.concat(restResults)));
    };
    return loadInBatches(importPaths).then((list) => list.reduce((acc, { importPath, csfFile }) => (acc[importPath] = csfFile, acc), {}));
  }
  cacheAllCSFFiles() {
    return this.initializationPromise.then(() => this.loadAllCSFFiles().then((csfFiles) => {
      this.cachedCSFFiles = csfFiles;
    }));
  }
  async loadStory({ storyId }) {
    await this.initializationPromise;
    let csfFile = await this.loadCSFFileByStoryId(storyId);
    return this.storyFromCSFFile({ storyId, csfFile });
  }
  storyFromCSFFile({ storyId, csfFile }) {
    if (!this.projectAnnotations)
      throw new Error("storyFromCSFFile called before initialization");
    let storyAnnotations = csfFile.stories[storyId];
    if (!storyAnnotations)
      throw new Error(`Didn't find '${storyId}' in CSF file, this is unexpected`);
    let componentAnnotations = csfFile.meta, story = this.prepareStoryWithCache(storyAnnotations, componentAnnotations, this.projectAnnotations);
    return this.args.setInitial(story), this.hooks[story.id] = this.hooks[story.id] || new HooksContext(), story;
  }
  componentStoriesFromCSFFile({ csfFile }) {
    if (!this.storyIndex)
      throw new Error("componentStoriesFromCSFFile called before initialization");
    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
  }
  async loadEntry(id) {
    let entry = await this.storyIdToEntry(id), { importFn, storyIndex } = this;
    if (!storyIndex || !importFn)
      throw new Error("loadEntry called before initialization");
    let storyImports = entry.type === "docs" ? entry.storiesImports : [], [entryExports, ...csfFiles] = await Promise.all([importFn(entry.importPath), ...storyImports.map((storyImportPath) => {
      let firstStoryEntry = storyIndex.importPathToEntry(storyImportPath);
      return this.loadCSFFileByStoryId(firstStoryEntry.id);
    })]);
    return { entryExports, csfFiles };
  }
  getStoryContext(story) {
    if (!this.globals)
      throw new Error("getStoryContext called before initialization");
    return { ...story, args: this.args.get(story.id), globals: this.globals.get(), hooks: this.hooks[story.id] };
  }
  cleanupStory(story) {
    this.hooks[story.id].clean();
  }
  extract(options = { includeDocsOnly: false }) {
    if (!this.storyIndex)
      throw new Error("extract called before initialization");
    let { cachedCSFFiles } = this;
    if (!cachedCSFFiles)
      throw new Error("Cannot call extract() unless you call cacheAllCSFFiles() first.");
    return Object.entries(this.storyIndex.entries).reduce((acc, [storyId, { type, importPath }]) => {
      if (type === "docs")
        return acc;
      let csfFile = cachedCSFFiles[importPath], story = this.storyFromCSFFile({ storyId, csfFile });
      return !options.includeDocsOnly && story.parameters.docsOnly || (acc[storyId] = Object.entries(story).reduce((storyAcc, [key, value]) => key === "moduleExport" || typeof value == "function" ? storyAcc : Array.isArray(value) ? Object.assign(storyAcc, { [key]: value.slice().sort() }) : Object.assign(storyAcc, { [key]: value }), { args: story.initialArgs })), acc;
    }, {});
  }
  getSetStoriesPayload() {
    if (!this.globals)
      throw new Error("getSetStoriesPayload called before initialization");
    let stories = this.extract({ includeDocsOnly: true }), kindParameters = Object.values(stories).reduce((acc, { title }) => (acc[title] = {}, acc), {});
    return { v: 2, globals: this.globals.get(), globalParameters: {}, kindParameters, stories };
  }
  getSetIndexPayload() {
    if (!this.storyIndex)
      throw new Error("getSetIndexPayload called before initialization");
    let stories = this.extract({ includeDocsOnly: true });
    return { v: 4, entries: Object.fromEntries(Object.entries(this.storyIndex.entries).map(([id, entry]) => [id, stories[id] ? { ...entry, args: stories[id].initialArgs, initialArgs: stories[id].initialArgs, argTypes: stories[id].argTypes, parameters: stories[id].parameters } : entry])) };
  }
  raw() {
    return Object.values(this.extract()).map(({ id }) => this.fromId(id)).filter(Boolean);
  }
  fromId(storyId) {
    if (!this.storyIndex)
      throw new Error("fromId called before initialization");
    if (!this.cachedCSFFiles)
      throw new Error("Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.");
    let importPath;
    try {
      ({ importPath } = this.storyIndex.storyIdToEntry(storyId));
    } catch {
      return null;
    }
    let csfFile = this.cachedCSFFiles[importPath], story = this.storyFromCSFFile({ storyId, csfFile });
    return { ...story, storyFn: (update) => {
      let context = { ...this.getStoryContext(story), viewMode: "story" };
      return story.unboundStoryFn({ ...context, ...update });
    } };
  }
};
var stripExtension = (path) => {
  let parts = [...path], last = parts[parts.length - 1], dotIndex = last.indexOf("."), stripped = dotIndex > 0 ? last.substr(0, dotIndex) : last;
  parts[parts.length - 1] = stripped;
  let [first, ...rest] = parts;
  return first === "" && (parts = rest), parts;
};
var indexRe = /^index$/i;
var removeRedundantFilename = (paths) => {
  let prevVal;
  return paths.filter((val, index) => index === paths.length - 1 && (val === prevVal || indexRe.test(val)) ? false : (prevVal = val, true));
};
function pathJoin(paths) {
  let slashes = new RegExp("/{1,}", "g");
  return paths.join("/").replace(slashes, "/");
}
var userOrAutoTitleFromSpecifier = (fileName, entry, userTitle) => {
  let { directory, importPathMatcher, titlePrefix = "" } = entry || {};
  typeof fileName == "number" && once.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let normalizedFileName = (0, import_slash.default)(String(fileName));
  if (importPathMatcher.exec(normalizedFileName)) {
    if (!userTitle) {
      let suffix = normalizedFileName.replace(directory, ""), path = (0, import_slash.default)(pathJoin([titlePrefix, suffix])).split("/");
      return path = stripExtension(path), path = removeRedundantFilename(path), path.join("/");
    }
    return titlePrefix ? (0, import_slash.default)(pathJoin([titlePrefix, userTitle])) : userTitle;
  }
};
var userOrAutoTitle = (fileName, storiesEntries, userTitle) => {
  for (let i = 0; i < storiesEntries.length; i += 1) {
    let title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i], userTitle);
    if (title)
      return title;
  }
  return userTitle || void 0;
};
var STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/;
var storySort = (options = {}) => (a, b) => {
  if (a.title === b.title && !options.includeNames)
    return 0;
  let method = options.method || "configure", order = options.order || [], storyTitleA = a.title.trim().split(STORY_KIND_PATH_SEPARATOR), storyTitleB = b.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  options.includeNames && (storyTitleA.push(a.name), storyTitleB.push(b.name));
  let depth = 0;
  for (; storyTitleA[depth] || storyTitleB[depth]; ) {
    if (!storyTitleA[depth])
      return -1;
    if (!storyTitleB[depth])
      return 1;
    let nameA = storyTitleA[depth], nameB = storyTitleB[depth];
    if (nameA !== nameB) {
      let indexA = order.indexOf(nameA), indexB = order.indexOf(nameB), indexWildcard = order.indexOf("*");
      return indexA !== -1 || indexB !== -1 ? (indexA === -1 && (indexWildcard !== -1 ? indexA = indexWildcard : indexA = order.length), indexB === -1 && (indexWildcard !== -1 ? indexB = indexWildcard : indexB = order.length), indexA - indexB) : method === "configure" ? 0 : nameA.localeCompare(nameB, options.locales ? options.locales : void 0, { numeric: true, sensitivity: "accent" });
    }
    let index = order.indexOf(nameA);
    index === -1 && (index = order.indexOf("*")), order = index !== -1 && Array.isArray(order[index + 1]) ? order[index + 1] : [], depth += 1;
  }
  return 0;
};
var sortStoriesCommon = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter) {
    let sortFn;
    typeof storySortParameter == "function" ? sortFn = storySortParameter : sortFn = storySort(storySortParameter), stories.sort(sortFn);
  } else
    stories.sort((s1, s2) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s2.importPath));
  return stories;
};
var toIndexEntry = (story) => {
  let { id, title, name, parameters, type } = story;
  return { id, title, name, importPath: parameters.fileName, type };
};
var sortStoriesV6 = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter && typeof storySortParameter == "function")
    return stories.sort(storySortParameter), stories.map((s) => toIndexEntry(s[1]));
  let storiesV7 = stories.map((s) => toIndexEntry(s[1]));
  return sortStoriesCommon(storiesV7, storySortParameter, fileNameOrder);
};

// node_modules/@storybook/preview-api/dist/chunk-7ZZCKEE2.mjs
var import_csf6 = __toESM(require_dist(), 1);
var import_synchronous_promise2 = __toESM(require_synchronous_promise(), 1);
var import_csf7 = __toESM(require_dist(), 1);
var import_qs = __toESM(require_lib(), 1);
var AUTODOCS_TAG = "autodocs";
var STORIES_MDX_TAG = "stories-mdx";
var StoryStoreFacade = class {
  constructor() {
    this.projectAnnotations = { loaders: [], decorators: [], parameters: {}, argsEnhancers: [], argTypesEnhancers: [], args: {}, argTypes: {} }, this.entries = {}, this.csfExports = {};
  }
  importFn(path) {
    return import_synchronous_promise2.SynchronousPromise.resolve().then(() => {
      let moduleExports = this.csfExports[path];
      if (!moduleExports)
        throw new Error(`Unknown path: ${path}`);
      return moduleExports;
    });
  }
  getStoryIndex(store) {
    var _a, _b;
    let fileNameOrder = Object.keys(this.csfExports), storySortParameter = (_b = (_a = this.projectAnnotations.parameters) == null ? void 0 : _a.options) == null ? void 0 : _b.storySort, sortableV6 = Object.entries(this.entries).map(([storyId, { type, importPath, ...entry }]) => {
      let exports = this.csfExports[importPath], csfFile = store.processCSFFileWithCache(exports, importPath, exports.default.title), storyLike;
      return type === "story" ? storyLike = store.storyFromCSFFile({ storyId, csfFile }) : storyLike = { ...entry, story: entry.name, kind: entry.title, componentId: (0, import_csf7.toId)(entry.componentId || entry.title), parameters: { fileName: importPath } }, [storyId, storyLike, csfFile.meta.parameters, this.projectAnnotations.parameters || {}];
    }), sortedV7;
    try {
      sortedV7 = sortStoriesV6(sortableV6, storySortParameter, fileNameOrder);
    } catch (err) {
      throw typeof storySortParameter == "function" ? new Error(dedent`
          Error sorting stories with sort parameter ${storySortParameter}:

          > ${err.message}
          
          Are you using a V7-style sort function in V6 compatibility mode?
          
          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
        `) : err;
    }
    return { v: 4, entries: sortedV7.reduce((acc, s) => (acc[s.id] = this.entries[s.id], acc), {}) };
  }
  clearFilenameExports(fileName) {
    this.csfExports[fileName] && (Object.entries(this.entries).forEach(([id, { importPath }]) => {
      importPath === fileName && delete this.entries[id];
    }), this.csfExports[fileName] = {});
  }
  addStoriesFromExports(fileName, fileExports) {
    if (fileName.match(/\.mdx$/) && !fileName.match(/\.stories\.mdx$/) || this.csfExports[fileName] === fileExports)
      return;
    this.clearFilenameExports(fileName);
    let { default: defaultExport, __namedExportsOrder, ...namedExports } = fileExports, { id: componentId, title, tags: componentTags = [] } = defaultExport || {}, specifiers = (scope.STORIES || []).map((specifier) => ({ ...specifier, importPathMatcher: new RegExp(specifier.importPathMatcher) }));
    if (title = userOrAutoTitle(fileName, specifiers, title), !title) {
      logger.info(`Unexpected default export without title in '${fileName}': ${JSON.stringify(fileExports.default)}`);
      return;
    }
    this.csfExports[fileName] = { ...fileExports, default: { ...defaultExport, title } };
    let sortedExports = namedExports;
    Array.isArray(__namedExportsOrder) && (sortedExports = {}, __namedExportsOrder.forEach((name) => {
      let namedExport = namedExports[name];
      namedExport && (sortedExports[name] = namedExport);
    }));
    let storyExports = Object.entries(sortedExports).filter(([key]) => (0, import_csf7.isExportStory)(key, defaultExport)), docsOptions = scope.DOCS_OPTIONS || {}, { autodocs } = docsOptions, componentAutodocs = componentTags.includes(AUTODOCS_TAG), autodocsOptedIn = autodocs === true || autodocs === "tag" && componentAutodocs;
    if (!docsOptions.disable && storyExports.length && (componentTags.includes(STORIES_MDX_TAG) || autodocsOptedIn)) {
      let name = docsOptions.defaultName, docsId = (0, import_csf7.toId)(componentId || title, name);
      this.entries[docsId] = { type: "docs", id: docsId, title, name, importPath: fileName, ...componentId && { componentId }, tags: [...componentTags, "docs", ...autodocsOptedIn && !componentAutodocs ? [AUTODOCS_TAG] : []], storiesImports: [] };
    }
    storyExports.forEach(([key, storyExport]) => {
      var _a, _b, _c;
      let exportName = (0, import_csf7.storyNameFromExport)(key), id = ((_a = storyExport.parameters) == null ? void 0 : _a.__id) || (0, import_csf7.toId)(componentId || title, exportName), name = typeof storyExport != "function" && storyExport.name || storyExport.storyName || ((_b = storyExport.story) == null ? void 0 : _b.name) || exportName;
      ((_c = storyExport.parameters) == null ? void 0 : _c.docsOnly) || (this.entries[id] = { type: "story", id, name, title, importPath: fileName, ...componentId && { componentId }, tags: [...storyExport.tags || componentTags, "story"] });
    });
  }
};
var invalidStoryTypes = /* @__PURE__ */ new Set(["string", "number", "boolean", "symbol"]);
var ClientApi = class {
  constructor({ storyStore } = {}) {
    this.lastFileName = 0;
    this.addDecorator = (decorator) => {
      var _a;
      (_a = this.facade.projectAnnotations.decorators) == null ? void 0 : _a.push(decorator);
    };
    this.addParameters = ({ globals, globalTypes, ...parameters }) => {
      this.facade.projectAnnotations.parameters = combineParameters(this.facade.projectAnnotations.parameters, parameters), globals && (this.facade.projectAnnotations.globals = { ...this.facade.projectAnnotations.globals, ...globals }), globalTypes && (this.facade.projectAnnotations.globalTypes = { ...this.facade.projectAnnotations.globalTypes, ...normalizeInputTypes(globalTypes) });
    };
    this.addStepRunner = (stepRunner) => {
      this.facade.projectAnnotations.runStep = composeStepRunners([this.facade.projectAnnotations.runStep, stepRunner].filter(Boolean));
    };
    this.addLoader = (loader) => {
      var _a;
      (_a = this.facade.projectAnnotations.loaders) == null ? void 0 : _a.push(loader);
    };
    this.addArgs = (args) => {
      this.facade.projectAnnotations.args = { ...this.facade.projectAnnotations.args, ...args };
    };
    this.addArgTypes = (argTypes) => {
      this.facade.projectAnnotations.argTypes = { ...this.facade.projectAnnotations.argTypes, ...normalizeInputTypes(argTypes) };
    };
    this.addArgsEnhancer = (enhancer) => {
      var _a;
      (_a = this.facade.projectAnnotations.argsEnhancers) == null ? void 0 : _a.push(enhancer);
    };
    this.addArgTypesEnhancer = (enhancer) => {
      var _a;
      (_a = this.facade.projectAnnotations.argTypesEnhancers) == null ? void 0 : _a.push(enhancer);
    };
    this._addedExports = {};
    this.storiesOf = (kind, m) => {
      if (!kind && typeof kind != "string")
        throw new Error("Invalid or missing kind provided for stories, should be a string");
      if (m || logger.warn(`Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`), m) {
        let proto = Object.getPrototypeOf(m);
        proto.exports && proto.exports.default && logger.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`);
      }
      let baseFilename = m && m.id ? `${m.id}` : (this.lastFileName++).toString(), fileName = baseFilename, i = 1;
      for (; this._addedExports[fileName]; )
        i += 1, fileName = `${baseFilename}-${i}`;
      m && m.hot && m.hot.accept && (m.hot.accept(), m.hot.dispose(() => {
        this.facade.clearFilenameExports(fileName), delete this._addedExports[fileName], setTimeout(() => {
          var _a;
          this._loadAddedExports(), (_a = this.onImportFnChanged) == null ? void 0 : _a.call(this, { importFn: this.importFn.bind(this) });
        }, 0);
      }));
      let hasAdded = false, api = { kind: kind.toString(), add: () => api, addDecorator: () => api, addLoader: () => api, addParameters: () => api };
      Object.keys(this.addons).forEach((name) => {
        let addon = this.addons[name];
        api[name] = (...args) => (addon.apply(api, args), api);
      });
      let meta = { id: (0, import_csf6.sanitize)(kind), title: kind, decorators: [], loaders: [], parameters: {} };
      this._addedExports[fileName] = { default: meta };
      let counter = 0;
      return api.add = (storyName, storyFn, parameters = {}) => {
        if (hasAdded = true, typeof storyName != "string")
          throw new Error(`Invalid or missing storyName provided for a "${kind}" story.`);
        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn))
          throw new Error(`Cannot load story "${storyName}" in "${kind}" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`);
        let { decorators, loaders, component, args, argTypes, ...storyParameters } = parameters, storyId = parameters.__id || (0, import_csf6.toId)(kind, storyName), csfExports = this._addedExports[fileName];
        return csfExports[`story${counter}`] = { name: storyName, parameters: { fileName, __id: storyId, ...storyParameters }, decorators, loaders, args, argTypes, component, render: storyFn }, counter += 1, api;
      }, api.addDecorator = (decorator) => {
        var _a;
        if (hasAdded)
          throw new Error(`You cannot add a decorator after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        return (_a = meta.decorators) == null ? void 0 : _a.push(decorator), api;
      }, api.addLoader = (loader) => {
        var _a;
        if (hasAdded)
          throw new Error("You cannot add a loader after the first story for a kind.");
        return (_a = meta.loaders) == null ? void 0 : _a.push(loader), api;
      }, api.addParameters = ({ component, args, argTypes, tags, ...parameters }) => {
        if (hasAdded)
          throw new Error(`You cannot add parameters after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        return meta.parameters = combineParameters(meta.parameters, parameters), component && (meta.component = component), args && (meta.args = { ...meta.args, ...args }), argTypes && (meta.argTypes = { ...meta.argTypes, ...argTypes }), tags && (meta.tags = tags), api;
      }, api;
    };
    this.raw = () => {
      var _a;
      return (_a = this.storyStore) == null ? void 0 : _a.raw();
    };
    this.facade = new StoryStoreFacade(), this.addons = {}, this.storyStore = storyStore;
  }
  importFn(path) {
    return this.facade.importFn(path);
  }
  getStoryIndex() {
    if (!this.storyStore)
      throw new Error("Cannot get story index before setting storyStore");
    return this.facade.getStoryIndex(this.storyStore);
  }
  _loadAddedExports() {
    Object.entries(this._addedExports).forEach(([fileName, fileExports]) => this.facade.addStoriesFromExports(fileName, fileExports));
  }
  get _storyStore() {
    return this.storyStore;
  }
};

// node_modules/@storybook/preview-api/dist/chunk-SJSTZ43Q.mjs
var import_synchronous_promise3 = __toESM(require_synchronous_promise(), 1);
var import_qs2 = __toESM(require_lib(), 1);
var import_qs3 = __toESM(require_lib(), 1);
var import_isPlainObject3 = __toESM(require_isPlainObject(), 1);
var import_qs4 = __toESM(require_lib(), 1);
var require_entities = __commonJS({ "../../node_modules/entities/lib/maps/entities.json"(exports, module) {
  module.exports = { Aacute: "", aacute: "", Abreve: "", abreve: "", ac: "", acd: "", acE: "", Acirc: "", acirc: "", acute: "", Acy: "", acy: "", AElig: "", aelig: "", af: "", Afr: "", afr: "", Agrave: "", agrave: "", alefsym: "", aleph: "", Alpha: "", alpha: "", Amacr: "", amacr: "", amalg: "", amp: "&", AMP: "&", andand: "", And: "", and: "", andd: "", andslope: "", andv: "", ang: "", ange: "", angle: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angmsd: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angst: "", angzarr: "", Aogon: "", aogon: "", Aopf: "", aopf: "", apacir: "", ap: "", apE: "", ape: "", apid: "", apos: "'", ApplyFunction: "", approx: "", approxeq: "", Aring: "", aring: "", Ascr: "", ascr: "", Assign: "", ast: "*", asymp: "", asympeq: "", Atilde: "", atilde: "", Auml: "", auml: "", awconint: "", awint: "", backcong: "", backepsilon: "", backprime: "", backsim: "", backsimeq: "", Backslash: "", Barv: "", barvee: "", barwed: "", Barwed: "", barwedge: "", bbrk: "", bbrktbrk: "", bcong: "", Bcy: "", bcy: "", bdquo: "", becaus: "", because: "", Because: "", bemptyv: "", bepsi: "", bernou: "", Bernoullis: "", Beta: "", beta: "", beth: "", between: "", Bfr: "", bfr: "", bigcap: "", bigcirc: "", bigcup: "", bigodot: "", bigoplus: "", bigotimes: "", bigsqcup: "", bigstar: "", bigtriangledown: "", bigtriangleup: "", biguplus: "", bigvee: "", bigwedge: "", bkarow: "", blacklozenge: "", blacksquare: "", blacktriangle: "", blacktriangledown: "", blacktriangleleft: "", blacktriangleright: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bNot: "", bnot: "", Bopf: "", bopf: "", bot: "", bottom: "", bowtie: "", boxbox: "", boxdl: "", boxdL: "", boxDl: "", boxDL: "", boxdr: "", boxdR: "", boxDr: "", boxDR: "", boxh: "", boxH: "", boxhd: "", boxHd: "", boxhD: "", boxHD: "", boxhu: "", boxHu: "", boxhU: "", boxHU: "", boxminus: "", boxplus: "", boxtimes: "", boxul: "", boxuL: "", boxUl: "", boxUL: "", boxur: "", boxuR: "", boxUr: "", boxUR: "", boxv: "", boxV: "", boxvh: "", boxvH: "", boxVh: "", boxVH: "", boxvl: "", boxvL: "", boxVl: "", boxVL: "", boxvr: "", boxvR: "", boxVr: "", boxVR: "", bprime: "", breve: "", Breve: "", brvbar: "", bscr: "", Bscr: "", bsemi: "", bsim: "", bsime: "", bsolb: "", bsol: "\\", bsolhsub: "", bull: "", bullet: "", bump: "", bumpE: "", bumpe: "", Bumpeq: "", bumpeq: "", Cacute: "", cacute: "", capand: "", capbrcup: "", capcap: "", cap: "", Cap: "", capcup: "", capdot: "", CapitalDifferentialD: "", caps: "", caret: "", caron: "", Cayleys: "", ccaps: "", Ccaron: "", ccaron: "", Ccedil: "", ccedil: "", Ccirc: "", ccirc: "", Cconint: "", ccups: "", ccupssm: "", Cdot: "", cdot: "", cedil: "", Cedilla: "", cemptyv: "", cent: "", centerdot: "", CenterDot: "", cfr: "", Cfr: "", CHcy: "", chcy: "", check: "", checkmark: "", Chi: "", chi: "", circ: "", circeq: "", circlearrowleft: "", circlearrowright: "", circledast: "", circledcirc: "", circleddash: "", CircleDot: "", circledR: "", circledS: "", CircleMinus: "", CirclePlus: "", CircleTimes: "", cir: "", cirE: "", cire: "", cirfnint: "", cirmid: "", cirscir: "", ClockwiseContourIntegral: "", CloseCurlyDoubleQuote: "", CloseCurlyQuote: "", clubs: "", clubsuit: "", colon: ":", Colon: "", Colone: "", colone: "", coloneq: "", comma: ",", commat: "@", comp: "", compfn: "", complement: "", complexes: "", cong: "", congdot: "", Congruent: "", conint: "", Conint: "", ContourIntegral: "", copf: "", Copf: "", coprod: "", Coproduct: "", copy: "", COPY: "", copysr: "", CounterClockwiseContourIntegral: "", crarr: "", cross: "", Cross: "", Cscr: "", cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", cuesc: "", cularr: "", cularrp: "", cupbrcap: "", cupcap: "", CupCap: "", cup: "", Cup: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curarrm: "", curlyeqprec: "", curlyeqsucc: "", curlyvee: "", curlywedge: "", curren: "", curvearrowleft: "", curvearrowright: "", cuvee: "", cuwed: "", cwconint: "", cwint: "", cylcty: "", dagger: "", Dagger: "", daleth: "", darr: "", Darr: "", dArr: "", dash: "", Dashv: "", dashv: "", dbkarow: "", dblac: "", Dcaron: "", dcaron: "", Dcy: "", dcy: "", ddagger: "", ddarr: "", DD: "", dd: "", DDotrahd: "", ddotseq: "", deg: "", Del: "", Delta: "", delta: "", demptyv: "", dfisht: "", Dfr: "", dfr: "", dHar: "", dharl: "", dharr: "", DiacriticalAcute: "", DiacriticalDot: "", DiacriticalDoubleAcute: "", DiacriticalGrave: "`", DiacriticalTilde: "", diam: "", diamond: "", Diamond: "", diamondsuit: "", diams: "", die: "", DifferentialD: "", digamma: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", DJcy: "", djcy: "", dlcorn: "", dlcrop: "", dollar: "$", Dopf: "", dopf: "", Dot: "", dot: "", DotDot: "", doteq: "", doteqdot: "", DotEqual: "", dotminus: "", dotplus: "", dotsquare: "", doublebarwedge: "", DoubleContourIntegral: "", DoubleDot: "", DoubleDownArrow: "", DoubleLeftArrow: "", DoubleLeftRightArrow: "", DoubleLeftTee: "", DoubleLongLeftArrow: "", DoubleLongLeftRightArrow: "", DoubleLongRightArrow: "", DoubleRightArrow: "", DoubleRightTee: "", DoubleUpArrow: "", DoubleUpDownArrow: "", DoubleVerticalBar: "", DownArrowBar: "", downarrow: "", DownArrow: "", Downarrow: "", DownArrowUpArrow: "", DownBreve: "", downdownarrows: "", downharpoonleft: "", downharpoonright: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVectorBar: "", DownLeftVector: "", DownRightTeeVector: "", DownRightVectorBar: "", DownRightVector: "", DownTeeArrow: "", DownTee: "", drbkarow: "", drcorn: "", drcrop: "", Dscr: "", dscr: "", DScy: "", dscy: "", dsol: "", Dstrok: "", dstrok: "", dtdot: "", dtri: "", dtrif: "", duarr: "", duhar: "", dwangle: "", DZcy: "", dzcy: "", dzigrarr: "", Eacute: "", eacute: "", easter: "", Ecaron: "", ecaron: "", Ecirc: "", ecirc: "", ecir: "", ecolon: "", Ecy: "", ecy: "", eDDot: "", Edot: "", edot: "", eDot: "", ee: "", efDot: "", Efr: "", efr: "", eg: "", Egrave: "", egrave: "", egs: "", egsdot: "", el: "", Element: "", elinters: "", ell: "", els: "", elsdot: "", Emacr: "", emacr: "", empty: "", emptyset: "", EmptySmallSquare: "", emptyv: "", EmptyVerySmallSquare: "", emsp13: "", emsp14: "", emsp: "", ENG: "", eng: "", ensp: "", Eogon: "", eogon: "", Eopf: "", eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", Epsilon: "", epsilon: "", epsiv: "", eqcirc: "", eqcolon: "", eqsim: "", eqslantgtr: "", eqslantless: "", Equal: "", equals: "=", EqualTilde: "", equest: "", Equilibrium: "", equiv: "", equivDD: "", eqvparsl: "", erarr: "", erDot: "", escr: "", Escr: "", esdot: "", Esim: "", esim: "", Eta: "", eta: "", ETH: "", eth: "", Euml: "", euml: "", euro: "", excl: "!", exist: "", Exists: "", expectation: "", exponentiale: "", ExponentialE: "", fallingdotseq: "", Fcy: "", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", Ffr: "", ffr: "", filig: "", FilledSmallSquare: "", FilledVerySmallSquare: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", Fopf: "", fopf: "", forall: "", ForAll: "", fork: "", forkv: "", Fouriertrf: "", fpartint: "", frac12: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", fscr: "", Fscr: "", gacute: "", Gamma: "", gamma: "", Gammad: "", gammad: "", gap: "", Gbreve: "", gbreve: "", Gcedil: "", Gcirc: "", gcirc: "", Gcy: "", gcy: "", Gdot: "", gdot: "", ge: "", gE: "", gEl: "", gel: "", geq: "", geqq: "", geqslant: "", gescc: "", ges: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", Gfr: "", gfr: "", gg: "", Gg: "", ggg: "", gimel: "", GJcy: "", gjcy: "", gla: "", gl: "", glE: "", glj: "", gnap: "", gnapprox: "", gne: "", gnE: "", gneq: "", gneqq: "", gnsim: "", Gopf: "", gopf: "", grave: "`", GreaterEqual: "", GreaterEqualLess: "", GreaterFullEqual: "", GreaterGreater: "", GreaterLess: "", GreaterSlantEqual: "", GreaterTilde: "", Gscr: "", gscr: "", gsim: "", gsime: "", gsiml: "", gtcc: "", gtcir: "", gt: ">", GT: ">", Gt: "", gtdot: "", gtlPar: "", gtquest: "", gtrapprox: "", gtrarr: "", gtrdot: "", gtreqless: "", gtreqqless: "", gtrless: "", gtrsim: "", gvertneqq: "", gvnE: "", Hacek: "", hairsp: "", half: "", hamilt: "", HARDcy: "", hardcy: "", harrcir: "", harr: "", hArr: "", harrw: "", Hat: "^", hbar: "", Hcirc: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", hercon: "", hfr: "", Hfr: "", HilbertSpace: "", hksearow: "", hkswarow: "", hoarr: "", homtht: "", hookleftarrow: "", hookrightarrow: "", hopf: "", Hopf: "", horbar: "", HorizontalLine: "", hscr: "", Hscr: "", hslash: "", Hstrok: "", hstrok: "", HumpDownHump: "", HumpEqual: "", hybull: "", hyphen: "", Iacute: "", iacute: "", ic: "", Icirc: "", icirc: "", Icy: "", icy: "", Idot: "", IEcy: "", iecy: "", iexcl: "", iff: "", ifr: "", Ifr: "", Igrave: "", igrave: "", ii: "", iiiint: "", iiint: "", iinfin: "", iiota: "", IJlig: "", ijlig: "", Imacr: "", imacr: "", image: "", ImaginaryI: "", imagline: "", imagpart: "", imath: "", Im: "", imof: "", imped: "", Implies: "", incare: "", in: "", infin: "", infintie: "", inodot: "", intcal: "", int: "", Int: "", integers: "", Integral: "", intercal: "", Intersection: "", intlarhk: "", intprod: "", InvisibleComma: "", InvisibleTimes: "", IOcy: "", iocy: "", Iogon: "", iogon: "", Iopf: "", iopf: "", Iota: "", iota: "", iprod: "", iquest: "", iscr: "", Iscr: "", isin: "", isindot: "", isinE: "", isins: "", isinsv: "", isinv: "", it: "", Itilde: "", itilde: "", Iukcy: "", iukcy: "", Iuml: "", iuml: "", Jcirc: "", jcirc: "", Jcy: "", jcy: "", Jfr: "", jfr: "", jmath: "", Jopf: "", jopf: "", Jscr: "", jscr: "", Jsercy: "", jsercy: "", Jukcy: "", jukcy: "", Kappa: "", kappa: "", kappav: "", Kcedil: "", kcedil: "", Kcy: "", kcy: "", Kfr: "", kfr: "", kgreen: "", KHcy: "", khcy: "", KJcy: "", kjcy: "", Kopf: "", kopf: "", Kscr: "", kscr: "", lAarr: "", Lacute: "", lacute: "", laemptyv: "", lagran: "", Lambda: "", lambda: "", lang: "", Lang: "", langd: "", langle: "", lap: "", Laplacetrf: "", laquo: "", larrb: "", larrbfs: "", larr: "", Larr: "", lArr: "", larrfs: "", larrhk: "", larrlp: "", larrpl: "", larrsim: "", larrtl: "", latail: "", lAtail: "", lat: "", late: "", lates: "", lbarr: "", lBarr: "", lbbrk: "", lbrace: "{", lbrack: "[", lbrke: "", lbrksld: "", lbrkslu: "", Lcaron: "", lcaron: "", Lcedil: "", lcedil: "", lceil: "", lcub: "{", Lcy: "", lcy: "", ldca: "", ldquo: "", ldquor: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", lE: "", LeftAngleBracket: "", LeftArrowBar: "", leftarrow: "", LeftArrow: "", Leftarrow: "", LeftArrowRightArrow: "", leftarrowtail: "", LeftCeiling: "", LeftDoubleBracket: "", LeftDownTeeVector: "", LeftDownVectorBar: "", LeftDownVector: "", LeftFloor: "", leftharpoondown: "", leftharpoonup: "", leftleftarrows: "", leftrightarrow: "", LeftRightArrow: "", Leftrightarrow: "", leftrightarrows: "", leftrightharpoons: "", leftrightsquigarrow: "", LeftRightVector: "", LeftTeeArrow: "", LeftTee: "", LeftTeeVector: "", leftthreetimes: "", LeftTriangleBar: "", LeftTriangle: "", LeftTriangleEqual: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVectorBar: "", LeftUpVector: "", LeftVectorBar: "", LeftVector: "", lEg: "", leg: "", leq: "", leqq: "", leqslant: "", lescc: "", les: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessapprox: "", lessdot: "", lesseqgtr: "", lesseqqgtr: "", LessEqualGreater: "", LessFullEqual: "", LessGreater: "", lessgtr: "", LessLess: "", lesssim: "", LessSlantEqual: "", LessTilde: "", lfisht: "", lfloor: "", Lfr: "", lfr: "", lg: "", lgE: "", lHar: "", lhard: "", lharu: "", lharul: "", lhblk: "", LJcy: "", ljcy: "", llarr: "", ll: "", Ll: "", llcorner: "", Lleftarrow: "", llhard: "", lltri: "", Lmidot: "", lmidot: "", lmoustache: "", lmoust: "", lnap: "", lnapprox: "", lne: "", lnE: "", lneq: "", lneqq: "", lnsim: "", loang: "", loarr: "", lobrk: "", longleftarrow: "", LongLeftArrow: "", Longleftarrow: "", longleftrightarrow: "", LongLeftRightArrow: "", Longleftrightarrow: "", longmapsto: "", longrightarrow: "", LongRightArrow: "", Longrightarrow: "", looparrowleft: "", looparrowright: "", lopar: "", Lopf: "", lopf: "", loplus: "", lotimes: "", lowast: "", lowbar: "_", LowerLeftArrow: "", LowerRightArrow: "", loz: "", lozenge: "", lozf: "", lpar: "(", lparlt: "", lrarr: "", lrcorner: "", lrhar: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", Lscr: "", lsh: "", Lsh: "", lsim: "", lsime: "", lsimg: "", lsqb: "[", lsquo: "", lsquor: "", Lstrok: "", lstrok: "", ltcc: "", ltcir: "", lt: "<", LT: "<", Lt: "", ltdot: "", lthree: "", ltimes: "", ltlarr: "", ltquest: "", ltri: "", ltrie: "", ltrif: "", ltrPar: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", macr: "", male: "", malt: "", maltese: "", Map: "", map: "", mapsto: "", mapstodown: "", mapstoleft: "", mapstoup: "", marker: "", mcomma: "", Mcy: "", mcy: "", mdash: "", mDDot: "", measuredangle: "", MediumSpace: "", Mellintrf: "", Mfr: "", mfr: "", mho: "", micro: "", midast: "*", midcir: "", mid: "", middot: "", minusb: "", minus: "", minusd: "", minusdu: "", MinusPlus: "", mlcp: "", mldr: "", mnplus: "", models: "", Mopf: "", mopf: "", mp: "", mscr: "", Mscr: "", mstpos: "", Mu: "", mu: "", multimap: "", mumap: "", nabla: "", Nacute: "", nacute: "", nang: "", nap: "", napE: "", napid: "", napos: "", napprox: "", natural: "", naturals: "", natur: "", nbsp: "", nbump: "", nbumpe: "", ncap: "", Ncaron: "", ncaron: "", Ncedil: "", ncedil: "", ncong: "", ncongdot: "", ncup: "", Ncy: "", ncy: "", ndash: "", nearhk: "", nearr: "", neArr: "", nearrow: "", ne: "", nedot: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", nequiv: "", nesear: "", nesim: "", NestedGreaterGreater: "", NestedLessLess: "", NewLine: `
`, nexist: "", nexists: "", Nfr: "", nfr: "", ngE: "", nge: "", ngeq: "", ngeqq: "", ngeqslant: "", nges: "", nGg: "", ngsim: "", nGt: "", ngt: "", ngtr: "", nGtv: "", nharr: "", nhArr: "", nhpar: "", ni: "", nis: "", nisd: "", niv: "", NJcy: "", njcy: "", nlarr: "", nlArr: "", nldr: "", nlE: "", nle: "", nleftarrow: "", nLeftarrow: "", nleftrightarrow: "", nLeftrightarrow: "", nleq: "", nleqq: "", nleqslant: "", nles: "", nless: "", nLl: "", nlsim: "", nLt: "", nlt: "", nltri: "", nltrie: "", nLtv: "", nmid: "", NoBreak: "", NonBreakingSpace: "", nopf: "", Nopf: "", Not: "", not: "", NotCongruent: "", NotCupCap: "", NotDoubleVerticalBar: "", NotElement: "", NotEqual: "", NotEqualTilde: "", NotExists: "", NotGreater: "", NotGreaterEqual: "", NotGreaterFullEqual: "", NotGreaterGreater: "", NotGreaterLess: "", NotGreaterSlantEqual: "", NotGreaterTilde: "", NotHumpDownHump: "", NotHumpEqual: "", notin: "", notindot: "", notinE: "", notinva: "", notinvb: "", notinvc: "", NotLeftTriangleBar: "", NotLeftTriangle: "", NotLeftTriangleEqual: "", NotLess: "", NotLessEqual: "", NotLessGreater: "", NotLessLess: "", NotLessSlantEqual: "", NotLessTilde: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", notni: "", notniva: "", notnivb: "", notnivc: "", NotPrecedes: "", NotPrecedesEqual: "", NotPrecedesSlantEqual: "", NotReverseElement: "", NotRightTriangleBar: "", NotRightTriangle: "", NotRightTriangleEqual: "", NotSquareSubset: "", NotSquareSubsetEqual: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", NotSubset: "", NotSubsetEqual: "", NotSucceeds: "", NotSucceedsEqual: "", NotSucceedsSlantEqual: "", NotSucceedsTilde: "", NotSuperset: "", NotSupersetEqual: "", NotTilde: "", NotTildeEqual: "", NotTildeFullEqual: "", NotTildeTilde: "", NotVerticalBar: "", nparallel: "", npar: "", nparsl: "", npart: "", npolint: "", npr: "", nprcue: "", nprec: "", npreceq: "", npre: "", nrarrc: "", nrarr: "", nrArr: "", nrarrw: "", nrightarrow: "", nRightarrow: "", nrtri: "", nrtrie: "", nsc: "", nsccue: "", nsce: "", Nscr: "", nscr: "", nshortmid: "", nshortparallel: "", nsim: "", nsime: "", nsimeq: "", nsmid: "", nspar: "", nsqsube: "", nsqsupe: "", nsub: "", nsubE: "", nsube: "", nsubset: "", nsubseteq: "", nsubseteqq: "", nsucc: "", nsucceq: "", nsup: "", nsupE: "", nsupe: "", nsupset: "", nsupseteq: "", nsupseteqq: "", ntgl: "", Ntilde: "", ntilde: "", ntlg: "", ntriangleleft: "", ntrianglelefteq: "", ntriangleright: "", ntrianglerighteq: "", Nu: "", nu: "", num: "#", numero: "", numsp: "", nvap: "", nvdash: "", nvDash: "", nVdash: "", nVDash: "", nvge: "", nvgt: ">", nvHarr: "", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwarhk: "", nwarr: "", nwArr: "", nwarrow: "", nwnear: "", Oacute: "", oacute: "", oast: "", Ocirc: "", ocirc: "", ocir: "", Ocy: "", ocy: "", odash: "", Odblac: "", odblac: "", odiv: "", odot: "", odsold: "", OElig: "", oelig: "", ofcir: "", Ofr: "", ofr: "", ogon: "", Ograve: "", ograve: "", ogt: "", ohbar: "", ohm: "", oint: "", olarr: "", olcir: "", olcross: "", oline: "", olt: "", Omacr: "", omacr: "", Omega: "", omega: "", Omicron: "", omicron: "", omid: "", ominus: "", Oopf: "", oopf: "", opar: "", OpenCurlyDoubleQuote: "", OpenCurlyQuote: "", operp: "", oplus: "", orarr: "", Or: "", or: "", ord: "", order: "", orderof: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oS: "", Oscr: "", oscr: "", Oslash: "", oslash: "", osol: "", Otilde: "", otilde: "", otimesas: "", Otimes: "", otimes: "", Ouml: "", ouml: "", ovbar: "", OverBar: "", OverBrace: "", OverBracket: "", OverParenthesis: "", para: "", parallel: "", par: "", parsim: "", parsl: "", part: "", PartialD: "", Pcy: "", pcy: "", percnt: "%", period: ".", permil: "", perp: "", pertenk: "", Pfr: "", pfr: "", Phi: "", phi: "", phiv: "", phmmat: "", phone: "", Pi: "", pi: "", pitchfork: "", piv: "", planck: "", planckh: "", plankv: "", plusacir: "", plusb: "", pluscir: "", plus: "+", plusdo: "", plusdu: "", pluse: "", PlusMinus: "", plusmn: "", plussim: "", plustwo: "", pm: "", Poincareplane: "", pointint: "", popf: "", Popf: "", pound: "", prap: "", Pr: "", pr: "", prcue: "", precapprox: "", prec: "", preccurlyeq: "", Precedes: "", PrecedesEqual: "", PrecedesSlantEqual: "", PrecedesTilde: "", preceq: "", precnapprox: "", precneqq: "", precnsim: "", pre: "", prE: "", precsim: "", prime: "", Prime: "", primes: "", prnap: "", prnE: "", prnsim: "", prod: "", Product: "", profalar: "", profline: "", profsurf: "", prop: "", Proportional: "", Proportion: "", propto: "", prsim: "", prurel: "", Pscr: "", pscr: "", Psi: "", psi: "", puncsp: "", Qfr: "", qfr: "", qint: "", qopf: "", Qopf: "", qprime: "", Qscr: "", qscr: "", quaternions: "", quatint: "", quest: "?", questeq: "", quot: '"', QUOT: '"', rAarr: "", race: "", Racute: "", racute: "", radic: "", raemptyv: "", rang: "", Rang: "", rangd: "", range: "", rangle: "", raquo: "", rarrap: "", rarrb: "", rarrbfs: "", rarrc: "", rarr: "", Rarr: "", rArr: "", rarrfs: "", rarrhk: "", rarrlp: "", rarrpl: "", rarrsim: "", Rarrtl: "", rarrtl: "", rarrw: "", ratail: "", rAtail: "", ratio: "", rationals: "", rbarr: "", rBarr: "", RBarr: "", rbbrk: "", rbrace: "}", rbrack: "]", rbrke: "", rbrksld: "", rbrkslu: "", Rcaron: "", rcaron: "", Rcedil: "", rcedil: "", rceil: "", rcub: "}", Rcy: "", rcy: "", rdca: "", rdldhar: "", rdquo: "", rdquor: "", rdsh: "", real: "", realine: "", realpart: "", reals: "", Re: "", rect: "", reg: "", REG: "", ReverseElement: "", ReverseEquilibrium: "", ReverseUpEquilibrium: "", rfisht: "", rfloor: "", rfr: "", Rfr: "", rHar: "", rhard: "", rharu: "", rharul: "", Rho: "", rho: "", rhov: "", RightAngleBracket: "", RightArrowBar: "", rightarrow: "", RightArrow: "", Rightarrow: "", RightArrowLeftArrow: "", rightarrowtail: "", RightCeiling: "", RightDoubleBracket: "", RightDownTeeVector: "", RightDownVectorBar: "", RightDownVector: "", RightFloor: "", rightharpoondown: "", rightharpoonup: "", rightleftarrows: "", rightleftharpoons: "", rightrightarrows: "", rightsquigarrow: "", RightTeeArrow: "", RightTee: "", RightTeeVector: "", rightthreetimes: "", RightTriangleBar: "", RightTriangle: "", RightTriangleEqual: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVectorBar: "", RightUpVector: "", RightVectorBar: "", RightVector: "", ring: "", risingdotseq: "", rlarr: "", rlhar: "", rlm: "", rmoustache: "", rmoust: "", rnmid: "", roang: "", roarr: "", robrk: "", ropar: "", ropf: "", Ropf: "", roplus: "", rotimes: "", RoundImplies: "", rpar: ")", rpargt: "", rppolint: "", rrarr: "", Rrightarrow: "", rsaquo: "", rscr: "", Rscr: "", rsh: "", Rsh: "", rsqb: "]", rsquo: "", rsquor: "", rthree: "", rtimes: "", rtri: "", rtrie: "", rtrif: "", rtriltri: "", RuleDelayed: "", ruluhar: "", rx: "", Sacute: "", sacute: "", sbquo: "", scap: "", Scaron: "", scaron: "", Sc: "", sc: "", sccue: "", sce: "", scE: "", Scedil: "", scedil: "", Scirc: "", scirc: "", scnap: "", scnE: "", scnsim: "", scpolint: "", scsim: "", Scy: "", scy: "", sdotb: "", sdot: "", sdote: "", searhk: "", searr: "", seArr: "", searrow: "", sect: "", semi: ";", seswar: "", setminus: "", setmn: "", sext: "", Sfr: "", sfr: "", sfrown: "", sharp: "", SHCHcy: "", shchcy: "", SHcy: "", shcy: "", ShortDownArrow: "", ShortLeftArrow: "", shortmid: "", shortparallel: "", ShortRightArrow: "", ShortUpArrow: "", shy: "", Sigma: "", sigma: "", sigmaf: "", sigmav: "", sim: "", simdot: "", sime: "", simeq: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", slarr: "", SmallCircle: "", smallsetminus: "", smashp: "", smeparsl: "", smid: "", smile: "", smt: "", smte: "", smtes: "", SOFTcy: "", softcy: "", solbar: "", solb: "", sol: "/", Sopf: "", sopf: "", spades: "", spadesuit: "", spar: "", sqcap: "", sqcaps: "", sqcup: "", sqcups: "", Sqrt: "", sqsub: "", sqsube: "", sqsubset: "", sqsubseteq: "", sqsup: "", sqsupe: "", sqsupset: "", sqsupseteq: "", square: "", Square: "", SquareIntersection: "", SquareSubset: "", SquareSubsetEqual: "", SquareSuperset: "", SquareSupersetEqual: "", SquareUnion: "", squarf: "", squ: "", squf: "", srarr: "", Sscr: "", sscr: "", ssetmn: "", ssmile: "", sstarf: "", Star: "", star: "", starf: "", straightepsilon: "", straightphi: "", strns: "", sub: "", Sub: "", subdot: "", subE: "", sube: "", subedot: "", submult: "", subnE: "", subne: "", subplus: "", subrarr: "", subset: "", Subset: "", subseteq: "", subseteqq: "", SubsetEqual: "", subsetneq: "", subsetneqq: "", subsim: "", subsub: "", subsup: "", succapprox: "", succ: "", succcurlyeq: "", Succeeds: "", SucceedsEqual: "", SucceedsSlantEqual: "", SucceedsTilde: "", succeq: "", succnapprox: "", succneqq: "", succnsim: "", succsim: "", SuchThat: "", sum: "", Sum: "", sung: "", sup1: "", sup2: "", sup3: "", sup: "", Sup: "", supdot: "", supdsub: "", supE: "", supe: "", supedot: "", Superset: "", SupersetEqual: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supne: "", supplus: "", supset: "", Supset: "", supseteq: "", supseteqq: "", supsetneq: "", supsetneqq: "", supsim: "", supsub: "", supsup: "", swarhk: "", swarr: "", swArr: "", swarrow: "", swnwar: "", szlig: "", Tab: "	", target: "", Tau: "", tau: "", tbrk: "", Tcaron: "", tcaron: "", Tcedil: "", tcedil: "", Tcy: "", tcy: "", tdot: "", telrec: "", Tfr: "", tfr: "", there4: "", therefore: "", Therefore: "", Theta: "", theta: "", thetasym: "", thetav: "", thickapprox: "", thicksim: "", ThickSpace: "", ThinSpace: "", thinsp: "", thkap: "", thksim: "", THORN: "", thorn: "", tilde: "", Tilde: "", TildeEqual: "", TildeFullEqual: "", TildeTilde: "", timesbar: "", timesb: "", times: "", timesd: "", tint: "", toea: "", topbot: "", topcir: "", top: "", Topf: "", topf: "", topfork: "", tosa: "", tprime: "", trade: "", TRADE: "", triangle: "", triangledown: "", triangleleft: "", trianglelefteq: "", triangleq: "", triangleright: "", trianglerighteq: "", tridot: "", trie: "", triminus: "", TripleDot: "", triplus: "", trisb: "", tritime: "", trpezium: "", Tscr: "", tscr: "", TScy: "", tscy: "", TSHcy: "", tshcy: "", Tstrok: "", tstrok: "", twixt: "", twoheadleftarrow: "", twoheadrightarrow: "", Uacute: "", uacute: "", uarr: "", Uarr: "", uArr: "", Uarrocir: "", Ubrcy: "", ubrcy: "", Ubreve: "", ubreve: "", Ucirc: "", ucirc: "", Ucy: "", ucy: "", udarr: "", Udblac: "", udblac: "", udhar: "", ufisht: "", Ufr: "", ufr: "", Ugrave: "", ugrave: "", uHar: "", uharl: "", uharr: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", Umacr: "", umacr: "", uml: "", UnderBar: "_", UnderBrace: "", UnderBracket: "", UnderParenthesis: "", Union: "", UnionPlus: "", Uogon: "", uogon: "", Uopf: "", uopf: "", UpArrowBar: "", uparrow: "", UpArrow: "", Uparrow: "", UpArrowDownArrow: "", updownarrow: "", UpDownArrow: "", Updownarrow: "", UpEquilibrium: "", upharpoonleft: "", upharpoonright: "", uplus: "", UpperLeftArrow: "", UpperRightArrow: "", upsi: "", Upsi: "", upsih: "", Upsilon: "", upsilon: "", UpTeeArrow: "", UpTee: "", upuparrows: "", urcorn: "", urcorner: "", urcrop: "", Uring: "", uring: "", urtri: "", Uscr: "", uscr: "", utdot: "", Utilde: "", utilde: "", utri: "", utrif: "", uuarr: "", Uuml: "", uuml: "", uwangle: "", vangrt: "", varepsilon: "", varkappa: "", varnothing: "", varphi: "", varpi: "", varpropto: "", varr: "", vArr: "", varrho: "", varsigma: "", varsubsetneq: "", varsubsetneqq: "", varsupsetneq: "", varsupsetneqq: "", vartheta: "", vartriangleleft: "", vartriangleright: "", vBar: "", Vbar: "", vBarv: "", Vcy: "", vcy: "", vdash: "", vDash: "", Vdash: "", VDash: "", Vdashl: "", veebar: "", vee: "", Vee: "", veeeq: "", vellip: "", verbar: "|", Verbar: "", vert: "|", Vert: "", VerticalBar: "", VerticalLine: "|", VerticalSeparator: "", VerticalTilde: "", VeryThinSpace: "", Vfr: "", vfr: "", vltri: "", vnsub: "", vnsup: "", Vopf: "", vopf: "", vprop: "", vrtri: "", Vscr: "", vscr: "", vsubnE: "", vsubne: "", vsupnE: "", vsupne: "", Vvdash: "", vzigzag: "", Wcirc: "", wcirc: "", wedbar: "", wedge: "", Wedge: "", wedgeq: "", weierp: "", Wfr: "", wfr: "", Wopf: "", wopf: "", wp: "", wr: "", wreath: "", Wscr: "", wscr: "", xcap: "", xcirc: "", xcup: "", xdtri: "", Xfr: "", xfr: "", xharr: "", xhArr: "", Xi: "", xi: "", xlarr: "", xlArr: "", xmap: "", xnis: "", xodot: "", Xopf: "", xopf: "", xoplus: "", xotime: "", xrarr: "", xrArr: "", Xscr: "", xscr: "", xsqcup: "", xuplus: "", xutri: "", xvee: "", xwedge: "", Yacute: "", yacute: "", YAcy: "", yacy: "", Ycirc: "", ycirc: "", Ycy: "", ycy: "", yen: "", Yfr: "", yfr: "", YIcy: "", yicy: "", Yopf: "", yopf: "", Yscr: "", yscr: "", YUcy: "", yucy: "", yuml: "", Yuml: "", Zacute: "", zacute: "", Zcaron: "", zcaron: "", Zcy: "", zcy: "", Zdot: "", zdot: "", zeetrf: "", ZeroWidthSpace: "", Zeta: "", zeta: "", zfr: "", Zfr: "", ZHcy: "", zhcy: "", zigrarr: "", zopf: "", Zopf: "", Zscr: "", zscr: "", zwj: "", zwnj: "" };
} });
var require_legacy = __commonJS({ "../../node_modules/entities/lib/maps/legacy.json"(exports, module) {
  module.exports = { Aacute: "", aacute: "", Acirc: "", acirc: "", acute: "", AElig: "", aelig: "", Agrave: "", agrave: "", amp: "&", AMP: "&", Aring: "", aring: "", Atilde: "", atilde: "", Auml: "", auml: "", brvbar: "", Ccedil: "", ccedil: "", cedil: "", cent: "", copy: "", COPY: "", curren: "", deg: "", divide: "", Eacute: "", eacute: "", Ecirc: "", ecirc: "", Egrave: "", egrave: "", ETH: "", eth: "", Euml: "", euml: "", frac12: "", frac14: "", frac34: "", gt: ">", GT: ">", Iacute: "", iacute: "", Icirc: "", icirc: "", iexcl: "", Igrave: "", igrave: "", iquest: "", Iuml: "", iuml: "", laquo: "", lt: "<", LT: "<", macr: "", micro: "", middot: "", nbsp: "", not: "", Ntilde: "", ntilde: "", Oacute: "", oacute: "", Ocirc: "", ocirc: "", Ograve: "", ograve: "", ordf: "", ordm: "", Oslash: "", oslash: "", Otilde: "", otilde: "", Ouml: "", ouml: "", para: "", plusmn: "", pound: "", quot: '"', QUOT: '"', raquo: "", reg: "", REG: "", sect: "", shy: "", sup1: "", sup2: "", sup3: "", szlig: "", THORN: "", thorn: "", times: "", Uacute: "", uacute: "", Ucirc: "", ucirc: "", Ugrave: "", ugrave: "", uml: "", Uuml: "", uuml: "", Yacute: "", yacute: "", yen: "", yuml: "" };
} });
var require_xml = __commonJS({ "../../node_modules/entities/lib/maps/xml.json"(exports, module) {
  module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
} });
var require_decode = __commonJS({ "../../node_modules/entities/lib/maps/decode.json"(exports, module) {
  module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
} });
var require_decode_codepoint = __commonJS({ "../../node_modules/entities/lib/decode_codepoint.js"(exports) {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var decode_json_1 = __importDefault(require_decode()), fromCodePoint = String.fromCodePoint || function(codePoint) {
    var output = "";
    return codePoint > 65535 && (codePoint -= 65536, output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), output += String.fromCharCode(codePoint), output;
  };
  function decodeCodePoint(codePoint) {
    return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? "" : (codePoint in decode_json_1.default && (codePoint = decode_json_1.default[codePoint]), fromCodePoint(codePoint));
  }
  exports.default = decodeCodePoint;
} });
var require_decode2 = __commonJS({ "../../node_modules/entities/lib/decode.js"(exports) {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
  var entities_json_1 = __importDefault(require_entities()), legacy_json_1 = __importDefault(require_legacy()), xml_json_1 = __importDefault(require_xml()), decode_codepoint_1 = __importDefault(require_decode_codepoint()), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  exports.decodeXML = getStrictDecoder(xml_json_1.default);
  exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
  function getStrictDecoder(map2) {
    var replace = getReplacer(map2);
    return function(str) {
      return String(str).replace(strictEntityRe, replace);
    };
  }
  var sorter = function(a, b) {
    return a < b ? 1 : -1;
  };
  exports.decodeHTML = function() {
    for (var legacy = Object.keys(legacy_json_1.default).sort(sorter), keys = Object.keys(entities_json_1.default).sort(sorter), i = 0, j = 0; i < keys.length; i++)
      legacy[j] === keys[i] ? (keys[i] += ";?", j++) : keys[i] += ";";
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entities_json_1.default);
    function replacer(str) {
      return str.substr(-1) !== ";" && (str += ";"), replace(str);
    }
    return function(str) {
      return String(str).replace(re, replacer);
    };
  }();
  function getReplacer(map2) {
    return function(str) {
      if (str.charAt(1) === "#") {
        var secondChar = str.charAt(2);
        return secondChar === "X" || secondChar === "x" ? decode_codepoint_1.default(parseInt(str.substr(3), 16)) : decode_codepoint_1.default(parseInt(str.substr(2), 10));
      }
      return map2[str.slice(1, -1)] || str;
    };
  }
} });
var require_encode = __commonJS({ "../../node_modules/entities/lib/encode.js"(exports) {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
  var xml_json_1 = __importDefault(require_xml()), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
  exports.encodeXML = getASCIIEncoder(inverseXML);
  var entities_json_1 = __importDefault(require_entities()), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
  exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
  function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function(inverse, name) {
      return inverse[obj[name]] = "&" + name + ";", inverse;
    }, {});
  }
  function getInverseReplacer(inverse) {
    for (var single = [], multiple = [], _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
      var k = _a[_i];
      k.length === 1 ? single.push("\\" + k) : multiple.push(k);
    }
    single.sort();
    for (var start2 = 0; start2 < single.length - 1; start2++) {
      for (var end = start2; end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1); )
        end += 1;
      var count = 1 + end - start2;
      count < 3 || single.splice(start2, count, single[start2] + "-" + single[end]);
    }
    return multiple.unshift("[" + single.join("") + "]"), new RegExp(multiple.join("|"), "g");
  }
  var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = String.prototype.codePointAt != null ? function(str) {
    return str.codePointAt(0);
  } : function(c) {
    return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
  };
  function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  function getInverse(inverse, re) {
    return function(data) {
      return data.replace(re, function(name) {
        return inverse[name];
      }).replace(reNonASCII, singleCharReplacer);
    };
  }
  var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
  function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
  }
  exports.escape = escape;
  function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
  }
  exports.escapeUTF8 = escapeUTF8;
  function getASCIIEncoder(obj) {
    return function(data) {
      return data.replace(reEscapeChars, function(c) {
        return obj[c] || singleCharReplacer(c);
      });
    };
  }
} });
var require_lib2 = __commonJS({ "../../node_modules/entities/lib/index.js"(exports) {
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
  var decode_1 = require_decode2(), encode_1 = require_encode();
  function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
  }
  exports.decode = decode;
  function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
  }
  exports.decodeStrict = decodeStrict;
  function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
  }
  exports.encode = encode;
  var encode_2 = require_encode();
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return encode_2.encodeXML;
  } });
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return encode_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return encode_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  var decode_2 = require_decode2();
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
} });
var require_ansi_to_html = __commonJS({ "../../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module) {
  "use strict";
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
  }
  function _createForOfIteratorHelper(o) {
    if (typeof Symbol > "u" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
        var i = 0, F = function() {
        };
        return { s: F, n: function() {
          return i >= o.length ? { done: true } : { done: false, value: o[i++] };
        }, e: function(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var it, normalCompletion = true, didErr = false, err;
    return { s: function() {
      it = o[Symbol.iterator]();
    }, n: function() {
      var step = it.next();
      return normalCompletion = step.done, step;
    }, e: function(_e2) {
      didErr = true, err = _e2;
    }, f: function() {
      try {
        !normalCompletion && it.return != null && it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (o) {
      if (typeof o == "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
  }
  function _arrayLikeToArray(arr, len) {
    (len == null || len > arr.length) && (len = arr.length);
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  var entities = require_lib2(), defaults = { fg: "#FFF", bg: "#000", newline: false, escapeXML: false, stream: false, colors: getDefaultColors() };
  function getDefaultColors() {
    var colors = { 0: "#000", 1: "#A00", 2: "#0A0", 3: "#A50", 4: "#00A", 5: "#A0A", 6: "#0AA", 7: "#AAA", 8: "#555", 9: "#F55", 10: "#5F5", 11: "#FF5", 12: "#55F", 13: "#F5F", 14: "#5FF", 15: "#FFF" };
    return range(0, 5).forEach(function(red) {
      range(0, 5).forEach(function(green) {
        range(0, 5).forEach(function(blue) {
          return setStyleColor(red, green, blue, colors);
        });
      });
    }), range(0, 23).forEach(function(gray) {
      var c = gray + 232, l = toHexString(gray * 10 + 8);
      colors[c] = "#" + l + l + l;
    }), colors;
  }
  function setStyleColor(red, green, blue, colors) {
    var c = 16 + red * 36 + green * 6 + blue, r = red > 0 ? red * 40 + 55 : 0, g = green > 0 ? green * 40 + 55 : 0, b = blue > 0 ? blue * 40 + 55 : 0;
    colors[c] = toColorHexString([r, g, b]);
  }
  function toHexString(num) {
    for (var str = num.toString(16); str.length < 2; )
      str = "0" + str;
    return str;
  }
  function toColorHexString(ref) {
    var results = [], _iterator = _createForOfIteratorHelper(ref), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var r = _step.value;
        results.push(toHexString(r));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return "#" + results.join("");
  }
  function generateOutput(stack, token, data, options) {
    var result;
    return token === "text" ? result = pushText(data, options) : token === "display" ? result = handleDisplay(stack, data, options) : token === "xterm256" ? result = pushForegroundColor(stack, options.colors[data]) : token === "rgb" && (result = handleRgb(stack, data)), result;
  }
  function handleRgb(stack, data) {
    data = data.substring(2).slice(0, -1);
    var operation = +data.substr(0, 2), color = data.substring(5).split(";"), rgb = color.map(function(value) {
      return ("0" + Number(value).toString(16)).substr(-2);
    }).join("");
    return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb);
  }
  function handleDisplay(stack, code, options) {
    code = parseInt(code, 10);
    var codeMap = { "-1": function() {
      return "<br/>";
    }, 0: function() {
      return stack.length && resetStyles(stack);
    }, 1: function() {
      return pushTag(stack, "b");
    }, 3: function() {
      return pushTag(stack, "i");
    }, 4: function() {
      return pushTag(stack, "u");
    }, 8: function() {
      return pushStyle(stack, "display:none");
    }, 9: function() {
      return pushTag(stack, "strike");
    }, 22: function() {
      return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
    }, 23: function() {
      return closeTag(stack, "i");
    }, 24: function() {
      return closeTag(stack, "u");
    }, 39: function() {
      return pushForegroundColor(stack, options.fg);
    }, 49: function() {
      return pushBackgroundColor(stack, options.bg);
    }, 53: function() {
      return pushStyle(stack, "text-decoration:overline");
    } }, result;
    return codeMap[code] ? result = codeMap[code]() : 4 < code && code < 7 ? result = pushTag(stack, "blink") : 29 < code && code < 38 ? result = pushForegroundColor(stack, options.colors[code - 30]) : 39 < code && code < 48 ? result = pushBackgroundColor(stack, options.colors[code - 40]) : 89 < code && code < 98 ? result = pushForegroundColor(stack, options.colors[8 + (code - 90)]) : 99 < code && code < 108 && (result = pushBackgroundColor(stack, options.colors[8 + (code - 100)])), result;
  }
  function resetStyles(stack) {
    var stackClone = stack.slice(0);
    return stack.length = 0, stackClone.reverse().map(function(tag) {
      return "</" + tag + ">";
    }).join("");
  }
  function range(low, high) {
    for (var results = [], j = low; j <= high; j++)
      results.push(j);
    return results;
  }
  function notCategory(category) {
    return function(e) {
      return (category === null || e.category !== category) && category !== "all";
    };
  }
  function categoryForCode(code) {
    code = parseInt(code, 10);
    var result = null;
    return code === 0 ? result = "all" : code === 1 ? result = "bold" : 2 < code && code < 5 ? result = "underline" : 4 < code && code < 7 ? result = "blink" : code === 8 ? result = "hide" : code === 9 ? result = "strike" : 29 < code && code < 38 || code === 39 || 89 < code && code < 98 ? result = "foreground-color" : (39 < code && code < 48 || code === 49 || 99 < code && code < 108) && (result = "background-color"), result;
  }
  function pushText(text, options) {
    return options.escapeXML ? entities.encodeXML(text) : text;
  }
  function pushTag(stack, tag, style) {
    return style || (style = ""), stack.push(tag), "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
  }
  function pushStyle(stack, style) {
    return pushTag(stack, "span", style);
  }
  function pushForegroundColor(stack, color) {
    return pushTag(stack, "span", "color:" + color);
  }
  function pushBackgroundColor(stack, color) {
    return pushTag(stack, "span", "background-color:" + color);
  }
  function closeTag(stack, style) {
    var last;
    if (stack.slice(-1)[0] === style && (last = stack.pop()), last)
      return "</" + style + ">";
  }
  function tokenize(text, options, callback) {
    var ansiMatch = false, ansiHandler = 3;
    function remove() {
      return "";
    }
    function removeXterm256(m, g1) {
      return callback("xterm256", g1), "";
    }
    function newline(m) {
      return options.newline ? callback("display", -1) : callback("text", m), "";
    }
    function ansiMess(m, g1) {
      ansiMatch = true, g1.trim().length === 0 && (g1 = "0"), g1 = g1.trimRight(";").split(";");
      var _iterator2 = _createForOfIteratorHelper(g1), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var g = _step2.value;
          callback("display", g);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return "";
    }
    function realText(m) {
      return callback("text", m), "";
    }
    function rgb(m) {
      return callback("rgb", m), "";
    }
    var tokens = [{ pattern: /^\x08+/, sub: remove }, { pattern: /^\x1b\[[012]?K/, sub: remove }, { pattern: /^\x1b\[\(B/, sub: remove }, { pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/, sub: rgb }, { pattern: /^\x1b\[38;5;(\d+)m/, sub: removeXterm256 }, { pattern: /^\n/, sub: newline }, { pattern: /^\r+\n/, sub: newline }, { pattern: /^\x1b\[((?:\d{1,3};?)+|)m/, sub: ansiMess }, { pattern: /^\x1b\[\d?J/, sub: remove }, { pattern: /^\x1b\[\d{0,3};\d{0,3}f/, sub: remove }, { pattern: /^\x1b\[?[\d;]{0,3}/, sub: remove }, { pattern: /^(([^\x1b\x08\r\n])+)/, sub: realText }];
    function process(handler2, i2) {
      i2 > ansiHandler && ansiMatch || (ansiMatch = false, text = text.replace(handler2.pattern, handler2.sub));
    }
    var results1 = [], _text = text, length = _text.length;
    outer:
      for (; length > 0; ) {
        for (var i = 0, o = 0, len = tokens.length; o < len; i = ++o) {
          var handler = tokens[i];
          if (process(handler, i), text.length !== length) {
            length = text.length;
            continue outer;
          }
        }
        if (text.length === length)
          break;
        results1.push(0), length = text.length;
      }
    return results1;
  }
  function updateStickyStack(stickyStack, token, data) {
    return token !== "text" && (stickyStack = stickyStack.filter(notCategory(categoryForCode(data))), stickyStack.push({ token, data, category: categoryForCode(data) })), stickyStack;
  }
  var Filter = function() {
    function Filter2(options) {
      _classCallCheck(this, Filter2), options = options || {}, options.colors && (options.colors = Object.assign({}, defaults.colors, options.colors)), this.options = Object.assign({}, defaults, options), this.stack = [], this.stickyStack = [];
    }
    return _createClass(Filter2, [{ key: "toHtml", value: function(input) {
      var _this = this;
      input = typeof input == "string" ? [input] : input;
      var stack = this.stack, options = this.options, buf = [];
      return this.stickyStack.forEach(function(element) {
        var output = generateOutput(stack, element.token, element.data, options);
        output && buf.push(output);
      }), tokenize(input.join(""), options, function(token, data) {
        var output = generateOutput(stack, token, data, options);
        output && buf.push(output), options.stream && (_this.stickyStack = updateStickyStack(_this.stickyStack, token, data));
      }), stack.length && buf.push(resetStyles(stack)), buf.join("");
    } }]), Filter2;
  }();
  module.exports = Filter;
} });
var PREPARE_ABORTED = new Error("prepareAborted");
var { AbortController } = globalThis;
function serializeError(error) {
  try {
    let { name = "Error", message = String(error), stack } = error;
    return { name, message, stack };
  } catch {
    return { name: "Error", message: String(error) };
  }
}
var StoryRender = class {
  constructor(channel, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: true, forceInitialArgs: false }, story) {
    this.channel = channel;
    this.store = store;
    this.renderToScreen = renderToScreen;
    this.callbacks = callbacks;
    this.id = id;
    this.viewMode = viewMode;
    this.renderOptions = renderOptions;
    this.type = "story";
    this.notYetRendered = true;
    this.disableKeyListeners = false;
    this.teardownRender = () => {
    };
    this.torndown = false;
    this.abortController = new AbortController(), story && (this.story = story, this.phase = "preparing");
  }
  async runPhase(signal, phase, phaseFn) {
    this.phase = phase, this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: this.phase, storyId: this.id }), phaseFn && await phaseFn(), signal.aborted && (this.phase = "aborted", this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: this.phase, storyId: this.id }));
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw this.store.cleanupStory(this.story), PREPARE_ABORTED;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["rendering", "playing"].includes(this.phase);
  }
  async renderToElement(canvasElement) {
    return this.canvasElement = canvasElement, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    return this.store.getStoryContext(this.story);
  }
  async render({ initial = false, forceRemount = false } = {}) {
    let { canvasElement } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    if (!canvasElement)
      throw new Error("cannot render when canvasElement is unset");
    let { id, componentId, title, name, tags, applyLoaders, unboundStoryFn, playFunction, prepareContext, initialArgs } = this.story;
    forceRemount && !initial && (this.cancelRender(), this.abortController = new AbortController());
    let abortSignal = this.abortController.signal;
    try {
      let getCurrentContext = () => prepareContext({ ...this.storyContext(), ...this.renderOptions.forceInitialArgs && { args: initialArgs } }), loadedContext;
      if (await this.runPhase(abortSignal, "loading", async () => {
        loadedContext = await applyLoaders({ ...getCurrentContext(), viewMode: this.viewMode });
      }), abortSignal.aborted)
        return;
      let renderStoryContext = { ...loadedContext, ...getCurrentContext(), abortSignal, canvasElement }, renderContext = { componentId, title, kind: title, id, name, story: name, tags, ...this.callbacks, showError: (error) => (this.phase = "errored", this.callbacks.showError(error)), showException: (error) => (this.phase = "errored", this.callbacks.showException(error)), forceRemount: forceRemount || this.notYetRendered, storyContext: renderStoryContext, storyFn: () => unboundStoryFn(renderStoryContext), unboundStoryFn };
      if (await this.runPhase(abortSignal, "rendering", async () => {
        let teardown = await this.renderToScreen(renderContext, canvasElement);
        this.teardownRender = teardown || (() => {
        });
      }), this.notYetRendered = false, abortSignal.aborted)
        return;
      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
        this.disableKeyListeners = true;
        try {
          await this.runPhase(abortSignal, "playing", async () => {
            await playFunction(renderContext.storyContext);
          }), await this.runPhase(abortSignal, "played");
        } catch (error) {
          if (logger.error(error), await this.runPhase(abortSignal, "errored", async () => {
            this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw error;
        }
        if (this.disableKeyListeners = false, abortSignal.aborted)
          return;
      }
      await this.runPhase(abortSignal, "completed", async () => this.channel.emit(STORY_RENDERED, id));
    } catch (err) {
      this.phase = "errored", this.callbacks.showException(err);
    }
  }
  async rerender() {
    return this.render();
  }
  async remount() {
    return this.render({ forceRemount: true });
  }
  cancelRender() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && this.store.cleanupStory(this.story);
    for (let i = 0; i < 3; i += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    window.location.reload(), await new Promise(() => {
    });
  }
};
var { fetch } = scope;
var STORY_INDEX_PATH = "./index.json";
var Preview = class {
  constructor(channel = addons.getChannel()) {
    var _a;
    this.channel = channel;
    this.storyRenders = [];
    ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) && addons.hasServerChannel() && (this.serverChannel = addons.getServerChannel()), this.storyStore = new StoryStore();
  }
  initialize({ getStoryIndex, importFn, getProjectAnnotations }) {
    return this.getStoryIndex = getStoryIndex, this.importFn = importFn, this.setupListeners(), this.getProjectAnnotationsOrRenderError(getProjectAnnotations).then((projectAnnotations) => this.initializeWithProjectAnnotations(projectAnnotations));
  }
  setupListeners() {
    var _a;
    (_a = this.serverChannel) == null ? void 0 : _a.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this)), this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this)), this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this)), this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this)), this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this)), this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this));
  }
  getProjectAnnotationsOrRenderError(getProjectAnnotations) {
    return import_synchronous_promise3.SynchronousPromise.resolve().then(getProjectAnnotations).then((projectAnnotations) => {
      if (projectAnnotations.renderToDOM && deprecate("`renderToDOM` is deprecated, please rename to `renderToCanvas`"), this.renderToCanvas = projectAnnotations.renderToCanvas || projectAnnotations.renderToDOM, !this.renderToCanvas)
        throw new Error(dedent`
            Expected your framework's preset to export a \`renderToCanvas\` field.

            Perhaps it needs to be upgraded for Storybook 6.4?

            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field
          `);
      return projectAnnotations;
    }).catch((err) => {
      throw this.renderPreviewEntryError("Error reading preview.js:", err), err;
    });
  }
  initializeWithProjectAnnotations(projectAnnotations) {
    var _a;
    this.storyStore.setProjectAnnotations(projectAnnotations), this.setInitialGlobals();
    let storyIndexPromise;
    if ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7)
      storyIndexPromise = this.getStoryIndexFromServer();
    else {
      if (!this.getStoryIndex)
        throw new Error("No `getStoryIndex` passed defined in v6 mode");
      storyIndexPromise = import_synchronous_promise3.SynchronousPromise.resolve().then(this.getStoryIndex);
    }
    return storyIndexPromise.then((storyIndex) => this.initializeWithStoryIndex(storyIndex)).catch((err) => {
      throw this.renderPreviewEntryError("Error loading story index:", err), err;
    });
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStore.globals || !this.storyStore.projectAnnotations)
      throw new Error("Cannot emit before initialization");
    let payload = { globals: this.storyStore.globals.get() || {}, globalTypes: this.storyStore.projectAnnotations.globalTypes || {} };
    this.channel.emit(SET_GLOBALS, payload);
  }
  async getStoryIndexFromServer() {
    let result = await fetch(STORY_INDEX_PATH);
    if (result.status === 200)
      return result.json();
    throw new Error(await result.text());
  }
  initializeWithStoryIndex(storyIndex) {
    var _a;
    if (!this.importFn)
      throw new Error("Cannot call initializeWithStoryIndex before initialization");
    return this.storyStore.initialize({ storyIndex, importFn: this.importFn, cache: !((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) });
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations }) {
    delete this.previewEntryError;
    let projectAnnotations = await this.getProjectAnnotationsOrRenderError(getProjectAnnotations);
    if (!this.storyStore.projectAnnotations) {
      await this.initializeWithProjectAnnotations(projectAnnotations);
      return;
    }
    await this.storyStore.setProjectAnnotations(projectAnnotations), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !!this.storyStore.projectAnnotations)
      try {
        let storyIndex = await this.getStoryIndexFromServer();
        this.storyStore.storyIndex || await this.initializeWithStoryIndex(storyIndex), await this.onStoriesChanged({ storyIndex });
      } catch (err) {
        throw this.renderPreviewEntryError("Error loading story index:", err), err;
      }
  }
  async onStoriesChanged({ importFn, storyIndex }) {
    await this.storyStore.onStoriesChanged({ importFn, storyIndex });
  }
  async onUpdateGlobals({ globals }) {
    if (!this.storyStore.globals)
      throw new Error("Cannot call onUpdateGlobals before initialization");
    this.storyStore.globals.update(globals), await Promise.all(this.storyRenders.map((r) => r.rerender())), this.channel.emit(GLOBALS_UPDATED, { globals: this.storyStore.globals.get(), initialGlobals: this.storyStore.globals.initialGlobals });
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    this.storyStore.args.update(storyId, updatedArgs), await Promise.all(this.storyRenders.filter((r) => r.id === storyId && !r.renderOptions.forceInitialArgs).map((r) => r.rerender())), this.channel.emit(STORY_ARGS_UPDATED, { storyId, args: this.storyStore.args.get(storyId) });
  }
  async onResetArgs({ storyId, argNames }) {
    var _a;
    let story = ((_a = this.storyRenders.find((r) => r.id === storyId)) == null ? void 0 : _a.story) || await this.storyStore.loadStory({ storyId }), updatedArgs = (argNames || [.../* @__PURE__ */ new Set([...Object.keys(story.initialArgs), ...Object.keys(this.storyStore.args.get(storyId))])]).reduce((acc, argName) => (acc[argName] = story.initialArgs[argName], acc), {});
    await this.onUpdateArgs({ storyId, updatedArgs });
  }
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((r) => r.rerender()));
  }
  async onForceRemount({ storyId }) {
    await Promise.all(this.storyRenders.filter((r) => r.id === storyId).map((r) => r.remount()));
  }
  renderStoryToElement(story, element, options) {
    if (!this.renderToCanvas)
      throw new Error("Cannot call renderStoryToElement before initialization");
    let render = new StoryRender(this.channel, this.storyStore, this.renderToCanvas, this.inlineStoryCallbacks(story.id), story.id, "docs", options, story);
    return render.renderToElement(element), this.storyRenders.push(render), async () => {
      await this.teardownRender(render);
    };
  }
  async teardownRender(render, { viewModeChanged } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((r) => r !== render), await ((_a = render == null ? void 0 : render.teardown) == null ? void 0 : _a.call(render, { viewModeChanged }));
  }
  async extract(options) {
    var _a;
    if (this.previewEntryError)
      throw this.previewEntryError;
    if (!this.storyStore.projectAnnotations)
      throw new Error(dedent`Failed to initialize Storybook.

      Do you have an error in your \`preview.js\`? Check your Storybook's browser console for errors.`);
    return ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) && await this.storyStore.cacheAllCSFFiles(), this.storyStore.extract(options);
  }
  inlineStoryCallbacks(storyId) {
    return { showMain: () => {
    }, showError: (err) => logger.error(`Error rendering docs story (${storyId})`, err), showException: (err) => logger.error(`Error rendering docs story (${storyId})`, err) };
  }
  renderPreviewEntryError(reason, err) {
    this.previewEntryError = err, logger.error(reason), logger.error(err), this.channel.emit(CONFIG_ERROR, err);
  }
};
var DocsContext = class {
  constructor(channel, store, renderStoryToElement, csfFiles) {
    this.channel = channel;
    this.store = store;
    this.renderStoryToElement = renderStoryToElement;
    this.storyIdByName = (storyName) => {
      let storyId = this.nameToStoryId.get(storyName);
      if (storyId)
        return storyId;
      throw new Error(`No story found with that name: ${storyName}`);
    };
    this.componentStories = () => this.componentStoriesValue;
    this.storyById = (storyId) => {
      if (!storyId) {
        if (!this.primaryStory)
          throw new Error("No primary story defined for docs entry. Did you forget to use `<Meta>`?");
        return this.primaryStory;
      }
      let csfFile = this.storyIdToCSFFile.get(storyId);
      if (!csfFile)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
      return this.store.storyFromCSFFile({ storyId, csfFile });
    };
    this.getStoryContext = (story) => ({ ...this.store.getStoryContext(story), viewMode: "docs" });
    this.loadStory = (id) => this.store.loadStory({ storyId: id });
    this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.componentStoriesValue = [], csfFiles.forEach((csfFile, index) => {
      this.referenceCSFFile(csfFile);
    });
  }
  referenceCSFFile(csfFile) {
    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile), this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      let annotation = csfFile.stories[story.id];
      this.storyIdToCSFFile.set(annotation.id, csfFile), this.exportToStory.set(annotation.moduleExport, story);
    });
  }
  attachCSFFile(csfFile) {
    if (!this.exportsToCSFFile.has(csfFile.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    this.attachedCSFFile = csfFile, this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      this.nameToStoryId.set(story.name, story.id), this.componentStoriesValue.push(story), this.primaryStory || (this.primaryStory = story);
    });
  }
  referenceMeta(metaExports, attach) {
    let resolved = this.resolveModuleExport(metaExports);
    if (resolved.type !== "meta")
      throw new Error("Cannot reference a non-meta or module export in <Meta of={} />");
    attach && this.attachCSFFile(resolved.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations } = this.store;
    if (!projectAnnotations)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return projectAnnotations;
  }
  resolveAttachedModuleExportType(moduleExportType) {
    if (moduleExportType === "story") {
      if (!this.primaryStory)
        throw new Error("No primary story attached to this docs file, did you forget to use <Meta of={} />?");
      return { type: "story", story: this.primaryStory };
    }
    if (!this.attachedCSFFile)
      throw new Error("No CSF file attached to this docs file, did you forget to use <Meta of={} />?");
    if (moduleExportType === "meta")
      return { type: "meta", csfFile: this.attachedCSFFile };
    let { component } = this.attachedCSFFile.meta;
    if (!component)
      throw new Error("Attached CSF file does not defined a component, did you forget to export one?");
    return { type: "component", component };
  }
  resolveModuleExport(moduleExportOrType) {
    let csfFile = this.exportsToCSFFile.get(moduleExportOrType);
    if (csfFile)
      return { type: "meta", csfFile };
    let story = this.exportToStory.get(moduleExportOrType);
    return story ? { type: "story", story } : { type: "component", component: moduleExportOrType };
  }
  resolveOf(moduleExportOrType, validTypes = []) {
    let resolved;
    if (["component", "meta", "story"].includes(moduleExportOrType)) {
      let type = moduleExportOrType;
      resolved = this.resolveAttachedModuleExportType(type);
    } else
      resolved = this.resolveModuleExport(moduleExportOrType);
    if (validTypes.length && !validTypes.includes(resolved.type)) {
      let prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
      throw new Error(`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(", ")}`);
    }
    return resolved;
  }
};
var CsfDocsRender = class {
  constructor(channel, store, entry) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.type = "docs";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    let { importPath, title } = this.entry, primaryCsfFile = this.store.processCSFFileWithCache(entryExports, importPath, title), primaryStoryId = Object.keys(primaryCsfFile.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile }), this.csfFiles = [primaryCsfFile, ...csfFiles], this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = new DocsContext(this.channel, this.store, renderStoryToElement, this.csfFiles);
    return this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile)), docsContext;
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs: docsParameter } = this.story.parameters || {};
    if (!docsParameter)
      throw new Error("Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed");
    let renderer = await docsParameter.renderer(), { render } = renderer, renderDocs = async () => {
      await new Promise((r) => render(docsContext, docsParameter, canvasElement, r)), this.channel.emit(DOCS_RENDERED, this.id);
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged }) => {
      !viewModeChanged || !canvasElement || renderer.unmount(canvasElement);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged }), this.torndown = true;
  }
};
var MdxDocsRender = class {
  constructor(channel, store, entry) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.type = "docs";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    this.csfFiles = csfFiles, this.exports = entryExports, this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.exports && this.exports === other.exports);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new DocsContext(this.channel, this.store, renderStoryToElement, this.csfFiles);
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs } = this.store.projectAnnotations.parameters || {};
    if (!docs)
      throw new Error("Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed");
    let docsParameter = { ...docs, page: this.exports.default }, renderer = await docs.renderer(), { render } = renderer, renderDocs = async () => {
      await new Promise((r) => render(docsContext, docsParameter, canvasElement, r)), this.channel.emit(DOCS_RENDERED, this.id);
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged } = {}) => {
      !viewModeChanged || !canvasElement || (renderer.unmount(canvasElement), this.torndown = true);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged }), this.torndown = true;
  }
};
var globalWindow = globalThis;
function focusInInput(event) {
  let target = event.target;
  return /input|textarea/i.test(target.tagName) || target.getAttribute("contenteditable") !== null;
}
var AUTODOCS_TAG2 = "autodocs";
var STORIES_MDX_TAG2 = "stories-mdx";
function isMdxEntry({ tags }) {
  return !(tags == null ? void 0 : tags.includes(AUTODOCS_TAG2)) && !(tags == null ? void 0 : tags.includes(STORIES_MDX_TAG2));
}
function isStoryRender(r) {
  return r.type === "story";
}
var PreviewWithSelection = class extends Preview {
  constructor(selectionStore, view) {
    super();
    this.selectionStore = selectionStore;
    this.view = view;
  }
  setupListeners() {
    super.setupListeners(), globalWindow.onkeydown = this.onKeydown.bind(this), this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this)), this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this)), this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));
  }
  initializeWithProjectAnnotations(projectAnnotations) {
    return super.initializeWithProjectAnnotations(projectAnnotations).then(() => this.setInitialGlobals());
  }
  async setInitialGlobals() {
    if (!this.storyStore.globals)
      throw new Error("Cannot call setInitialGlobals before initialization");
    let { globals } = this.selectionStore.selectionSpecifier || {};
    globals && this.storyStore.globals.updateFromPersisted(globals), this.emitGlobals();
  }
  initializeWithStoryIndex(storyIndex) {
    return super.initializeWithStoryIndex(storyIndex).then(() => {
      var _a;
      return ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) || this.channel.emit(SET_INDEX, this.storyStore.getSetIndexPayload()), this.selectSpecifiedStory();
    });
  }
  async selectSpecifiedStory() {
    if (!this.storyStore.storyIndex)
      throw new Error("Cannot call selectSpecifiedStory before initialization");
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier, args } = this.selectionStore.selectionSpecifier, entry = this.storyStore.storyIndex.entryFromSpecifier(storySpecifier);
    if (!entry) {
      storySpecifier === "*" ? this.renderStoryLoadingException(storySpecifier, new Error(dedent`
            Couldn't find any stories in your Storybook.
            - Please check your stories field of your main.js config.
            - Also check the browser console and terminal for error messages.
          `)) : this.renderStoryLoadingException(storySpecifier, new Error(dedent`
            Couldn't find story matching '${storySpecifier}'.
            - Are you sure a story with that id exists?
            - Please check your stories field of your main.js config.
            - Also check the browser console and terminal for error messages.
          `));
      return;
    }
    let { id: storyId, type: viewMode } = entry;
    this.selectionStore.setSelection({ storyId, viewMode }), this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), await this.renderSelection({ persistedArgs: args });
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations }), this.selectionStore.selection && this.renderSelection();
  }
  async onStoriesChanged({ importFn, storyIndex }) {
    var _a;
    await super.onStoriesChanged({ importFn, storyIndex }), ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) || this.channel.emit(SET_INDEX, await this.storyStore.getSetIndexPayload()), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(event) {
    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !focusInInput(event)) {
      let { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;
      this.channel.emit(PREVIEW_KEYDOWN, { event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } });
    }
  }
  async onSetCurrentStory(selection) {
    await this.storyStore.initializationPromise, this.selectionStore.setSelection({ viewMode: "story", ...selection }), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(queryParams) {
    this.selectionStore.setQueryParams(queryParams);
  }
  async onUpdateGlobals({ globals }) {
    var _a, _b;
    super.onUpdateGlobals({ globals }), (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) && await ((_b = (_a = this.currentRender).rerender) == null ? void 0 : _b.call(_a));
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    super.onUpdateArgs({ storyId, updatedArgs });
  }
  async onPreloadStories({ ids }) {
    await Promise.allSettled(ids.map((id) => this.storyStore.loadEntry(id)));
  }
  async renderSelection({ persistedArgs } = {}) {
    var _a, _b, _c, _d;
    let { renderToCanvas } = this;
    if (!renderToCanvas)
      throw new Error("Cannot call renderSelection before initialization");
    let { selection } = this.selectionStore;
    if (!selection)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId } = selection, entry;
    try {
      entry = await this.storyStore.storyIdToEntry(storyId);
    } catch (err) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(storyId, err);
      return;
    }
    let storyIdChanged = ((_a = this.currentSelection) == null ? void 0 : _a.storyId) !== storyId, viewModeChanged = ((_b = this.currentRender) == null ? void 0 : _b.type) !== entry.type;
    entry.type === "story" ? this.view.showPreparingStory({ immediate: viewModeChanged }) : this.view.showPreparingDocs({ immediate: viewModeChanged }), ((_c = this.currentRender) == null ? void 0 : _c.isPreparing()) && await this.teardownRender(this.currentRender);
    let render;
    entry.type === "story" ? render = new StoryRender(this.channel, this.storyStore, (...args) => (this.view.showStoryDuringRender(), renderToCanvas(...args)), this.mainStoryCallbacks(storyId), storyId, "story") : isMdxEntry(entry) ? render = new MdxDocsRender(this.channel, this.storyStore, entry) : render = new CsfDocsRender(this.channel, this.storyStore, entry);
    let lastSelection = this.currentSelection;
    this.currentSelection = selection;
    let lastRender = this.currentRender;
    this.currentRender = render;
    try {
      await render.prepare();
    } catch (err) {
      err !== PREPARE_ABORTED && (lastRender && await this.teardownRender(lastRender), this.renderStoryLoadingException(storyId, err));
      return;
    }
    let implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);
    if (persistedArgs && isStoryRender(render)) {
      if (!render.story)
        throw new Error("Render has not been prepared!");
      this.storyStore.args.updateFromPersisted(render.story, persistedArgs);
    }
    if (lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {
      this.currentRender = lastRender, this.channel.emit(STORY_UNCHANGED, storyId), this.view.showMain();
      return;
    }
    if (lastRender && await this.teardownRender(lastRender, { viewModeChanged }), lastSelection && (storyIdChanged || viewModeChanged) && this.channel.emit(STORY_CHANGED, storyId), isStoryRender(render)) {
      if (!render.story)
        throw new Error("Render has not been prepared!");
      let { parameters, initialArgs, argTypes, args } = this.storyStore.getStoryContext(render.story);
      ((_d = scope.FEATURES) == null ? void 0 : _d.storyStoreV7) && this.channel.emit(STORY_PREPARED, { id: storyId, parameters, initialArgs, argTypes, args }), (implementationChanged || persistedArgs) && this.channel.emit(STORY_ARGS_UPDATED, { storyId, args });
    }
    if (isStoryRender(render)) {
      if (!render.story)
        throw new Error("Render has not been prepared!");
      this.storyRenders.push(render), this.currentRender.renderToElement(this.view.prepareForStory(render.story));
    } else
      this.currentRender.renderToElement(this.view.prepareForDocs(), this.renderStoryToElement.bind(this));
  }
  async teardownRender(render, { viewModeChanged = false } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((r) => r !== render), await ((_a = render == null ? void 0 : render.teardown) == null ? void 0 : _a.call(render, { viewModeChanged }));
  }
  async extract(options) {
    var _a;
    if (this.previewEntryError)
      throw this.previewEntryError;
    if (!this.storyStore.projectAnnotations)
      throw new Error(dedent`Failed to initialize Storybook.

      Do you have an error in your \`preview.js\`? Check your Storybook's browser console for errors.`);
    return ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) && await this.storyStore.cacheAllCSFFiles(), this.storyStore.extract(options);
  }
  mainStoryCallbacks(storyId) {
    return { showMain: () => this.view.showMain(), showError: (err) => this.renderError(storyId, err), showException: (err) => this.renderException(storyId, err) };
  }
  inlineStoryCallbacks(storyId) {
    return { showMain: () => {
    }, showError: (err) => logger.error(`Error rendering docs story (${storyId})`, err), showException: (err) => logger.error(`Error rendering docs story (${storyId})`, err) };
  }
  renderPreviewEntryError(reason, err) {
    super.renderPreviewEntryError(reason, err), this.view.showErrorDisplay(err);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(STORY_MISSING);
  }
  renderStoryLoadingException(storySpecifier, err) {
    logger.error(err), this.view.showErrorDisplay(err), this.channel.emit(STORY_MISSING, storySpecifier);
  }
  renderException(storyId, error) {
    var _a;
    let { name = "Error", message = String(error), stack } = error;
    this.channel.emit(STORY_THREW_EXCEPTION, { name, message, stack }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", storyId }), ((_a = error.message) == null ? void 0 : _a.startsWith("ignoredException")) || (this.view.showErrorDisplay(error), logger.error(`Error rendering story '${storyId}':`), logger.error(error));
  }
  renderError(storyId, { title, description }) {
    logger.error(`Error rendering story ${title}: ${description}`), this.channel.emit(STORY_ERRORED, { title, description }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", storyId }), this.view.showErrorDisplay({ message: title, stack: description });
  }
};
var VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;
var NUMBER_REGEXP = /^-?[0-9]+(\.[0-9]+)?$/;
var HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var COLOR_REGEXP = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var validateArgs = (key = "", value) => key === null || key === "" || !VALIDATION_REGEXP.test(key) ? false : value == null || value instanceof Date || typeof value == "number" || typeof value == "boolean" ? true : typeof value == "string" ? VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value) : Array.isArray(value) ? value.every((v) => validateArgs(key, v)) : (0, import_isPlainObject3.default)(value) ? Object.entries(value).every(([k, v]) => validateArgs(k, v)) : false;
var QS_OPTIONS = { delimiter: ";", allowDots: true, allowSparse: true, decoder(str, defaultDecoder, charset, type) {
  if (type === "value" && str.startsWith("!")) {
    if (str === "!undefined")
      return;
    if (str === "!null")
      return null;
    if (str.startsWith("!date(") && str.endsWith(")"))
      return new Date(str.slice(6, -1));
    if (str.startsWith("!hex(") && str.endsWith(")"))
      return `#${str.slice(5, -1)}`;
    let color = str.slice(1).match(COLOR_REGEXP);
    if (color)
      return str.startsWith("!rgba") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})` : str.startsWith("!hsla") ? `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})` : str.startsWith("!rgb") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;
  }
  return type === "value" && NUMBER_REGEXP.test(str) ? Number(str) : defaultDecoder(str, defaultDecoder, charset);
} };
var parseArgsParam = (argsString) => {
  let parts = argsString.split(";").map((part) => part.replace("=", "~").replace(":", "="));
  return Object.entries(import_qs3.default.parse(parts.join(";"), QS_OPTIONS)).reduce((acc, [key, value]) => validateArgs(key, value) ? Object.assign(acc, { [key]: value }) : (once.warn(dedent`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url
    `), acc), {});
};
var { history, document } = scope;
function pathToId(path) {
  let match = (path || "").match(/^\/story\/(.+)/);
  if (!match)
    throw new Error(`Invalid path '${path}',  must start with '/story/'`);
  return match[1];
}
var getQueryString = ({ selection, extraParams }) => {
  let { search = "" } = document.location, { path, selectedKind, selectedStory, ...rest } = import_qs2.default.parse(search, { ignoreQueryPrefix: true });
  return import_qs2.default.stringify({ ...rest, ...extraParams, ...selection && { id: selection.storyId, viewMode: selection.viewMode } }, { encode: false, addQueryPrefix: true });
};
var setPath = (selection) => {
  if (!selection)
    return;
  let query = getQueryString({ selection }), { hash = "" } = document.location;
  document.title = selection.storyId, history.replaceState({}, "", `${document.location.pathname}${query}${hash}`);
};
var isObject = (val) => val != null && typeof val == "object" && Array.isArray(val) === false;
var getFirstString = (v) => {
  if (v !== void 0) {
    if (typeof v == "string")
      return v;
    if (Array.isArray(v))
      return getFirstString(v[0]);
    if (isObject(v))
      return getFirstString(Object.values(v).filter(Boolean));
  }
};
var getSelectionSpecifierFromPath = () => {
  let query = import_qs2.default.parse(document.location.search, { ignoreQueryPrefix: true }), args = typeof query.args == "string" ? parseArgsParam(query.args) : void 0, globals = typeof query.globals == "string" ? parseArgsParam(query.globals) : void 0, viewMode = getFirstString(query.viewMode);
  (typeof viewMode != "string" || !viewMode.match(/docs|story/)) && (viewMode = "story");
  let path = getFirstString(query.path), storyId = path ? pathToId(path) : getFirstString(query.id);
  return storyId ? { storySpecifier: storyId, args, globals, viewMode } : null;
};
var UrlStore = class {
  constructor() {
    this.selectionSpecifier = getSelectionSpecifierFromPath();
  }
  setSelection(selection) {
    this.selection = selection, setPath(this.selection);
  }
  setQueryParams(queryParams) {
    let query = getQueryString({ extraParams: queryParams }), { hash = "" } = document.location;
    history.replaceState({}, "", `${document.location.pathname}${query}${hash}`);
  }
};
var import_ansi_to_html = __toESM2(require_ansi_to_html());
var { document: document2 } = scope;
var PREPARING_DELAY = 100;
var Mode = ((Mode2) => (Mode2.MAIN = "MAIN", Mode2.NOPREVIEW = "NOPREVIEW", Mode2.PREPARING_STORY = "PREPARING_STORY", Mode2.PREPARING_DOCS = "PREPARING_DOCS", Mode2.ERROR = "ERROR", Mode2))(Mode || {});
var classes = { PREPARING_STORY: "sb-show-preparing-story", PREPARING_DOCS: "sb-show-preparing-docs", MAIN: "sb-show-main", NOPREVIEW: "sb-show-nopreview", ERROR: "sb-show-errordisplay" };
var layoutClassMap = { centered: "sb-main-centered", fullscreen: "sb-main-fullscreen", padded: "sb-main-padded" };
var ansiConverter = new import_ansi_to_html.default({ escapeXML: true });
var WebView = class {
  constructor() {
    this.testing = false;
    let { __SPECIAL_TEST_PARAMETER__ } = import_qs4.default.parse(document2.location.search, { ignoreQueryPrefix: true });
    switch (__SPECIAL_TEST_PARAMETER__) {
      case "preparing-story": {
        this.showPreparingStory(), this.testing = true;
        break;
      }
      case "preparing-docs": {
        this.showPreparingDocs(), this.testing = true;
        break;
      }
      default:
    }
  }
  prepareForStory(story) {
    return this.showStory(), this.applyLayout(story.parameters.layout), document2.documentElement.scrollTop = 0, document2.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return document2.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), this.docsRoot();
  }
  docsRoot() {
    return document2.getElementById("storybook-docs");
  }
  applyLayout(layout = "padded") {
    if (layout === "none") {
      document2.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(layout);
    let layoutClass = layoutClassMap[layout];
    document2.body.classList.remove(this.currentLayoutClass), document2.body.classList.add(layoutClass), this.currentLayoutClass = layoutClass;
  }
  checkIfLayoutExists(layout) {
    layoutClassMap[layout] || logger.warn(dedent`The desired layout: ${layout} is not a valid option.
         The possible options are: ${Object.keys(layoutClassMap).join(", ")}, none.`);
  }
  showMode(mode) {
    clearTimeout(this.preparingTimeout), Object.keys(Mode).forEach((otherMode) => {
      otherMode === mode ? document2.body.classList.add(classes[otherMode]) : document2.body.classList.remove(classes[otherMode]);
    });
  }
  showErrorDisplay({ message = "", stack = "" }) {
    let header = message, detail = stack, parts = message.split(`
`);
    parts.length > 1 && ([header] = parts, detail = parts.slice(1).join(`
`)), document2.getElementById("error-message").innerHTML = ansiConverter.toHtml(header), document2.getElementById("error-stack").innerHTML = ansiConverter.toHtml(detail), this.showMode("ERROR");
  }
  showNoPreview() {
    var _a, _b;
    this.testing || (this.showMode("NOPREVIEW"), (_a = this.storyRoot()) == null ? void 0 : _a.setAttribute("hidden", "true"), (_b = this.docsRoot()) == null ? void 0 : _b.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode("PREPARING_STORY") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_STORY"), PREPARING_DELAY);
  }
  showPreparingDocs({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode("PREPARING_DOCS") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS"), PREPARING_DELAY);
  }
  showMain() {
    this.showMode("MAIN");
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    document2.body.classList.add(classes.MAIN);
  }
};
var PreviewWeb = class extends PreviewWithSelection {
  constructor() {
    super(new UrlStore(), new WebView()), scope.__STORYBOOK_PREVIEW__ = this;
  }
};
var { document: document3 } = scope;

// node_modules/@storybook/preview-api/dist/chunk-YND6GPMW.mjs
function executeLoadable(loadable) {
  let reqs = null;
  Array.isArray(loadable) ? reqs = loadable : loadable.keys && (reqs = [loadable]);
  let exportsMap = /* @__PURE__ */ new Map();
  if (reqs)
    reqs.forEach((req) => {
      req.keys().forEach((filename) => {
        try {
          let fileExports = req(filename);
          exportsMap.set(typeof req.resolve == "function" ? req.resolve(filename) : filename, fileExports);
        } catch (error) {
          let errorString = error.message && error.stack ? `${error.message}
 ${error.stack}` : error.toString();
          logger.error(`Unexpected error while loading ${filename}: ${errorString}`);
        }
      });
    });
  else {
    let exported = loadable();
    Array.isArray(exported) && exported.every((obj) => obj.default != null) ? exportsMap = new Map(exported.map((fileExports, index) => [`exports-map-${index}`, fileExports])) : exported && logger.warn(`Loader function passed to 'configure' should return void or an array of module exports that all contain a 'default' export. Received: ${JSON.stringify(exported)}`);
  }
  return exportsMap;
}
function executeLoadableForChanges(loadable, m) {
  var _a, _b, _c;
  let lastExportsMap = ((_b = (_a = m == null ? void 0 : m.hot) == null ? void 0 : _a.data) == null ? void 0 : _b.lastExportsMap) || /* @__PURE__ */ new Map();
  ((_c = m == null ? void 0 : m.hot) == null ? void 0 : _c.dispose) && (m.hot.accept(), m.hot.dispose((data) => {
    data.lastExportsMap = lastExportsMap;
  }));
  let exportsMap = executeLoadable(loadable), added = /* @__PURE__ */ new Map();
  Array.from(exportsMap.entries()).filter(([, fileExports]) => !!fileExports.default).filter(([fileName, fileExports]) => lastExportsMap.get(fileName) !== fileExports).forEach(([fileName, fileExports]) => added.set(fileName, fileExports));
  let removed = /* @__PURE__ */ new Map();
  return Array.from(lastExportsMap.keys()).filter((fileName) => !exportsMap.has(fileName)).forEach((fileName) => {
    let value = lastExportsMap.get(fileName);
    value && removed.set(fileName, value);
  }), lastExportsMap = exportsMap, { added, removed };
}
var { FEATURES } = scope;
var removedApi = (name) => () => {
  throw new Error(`@storybook/client-api:${name} was removed in storyStoreV7.`);
};
function start(renderToCanvas, { decorateStory: decorateStory2, render } = {}) {
  var _a, _b;
  if (scope && (scope.IS_STORYBOOK = true), FEATURES == null ? void 0 : FEATURES.storyStoreV7)
    return { forceReRender: removedApi("forceReRender"), configure: removedApi("configure"), clientApi: { storiesOf: removedApi("clientApi.storiesOf"), raw: removedApi("raw") } };
  let channel = createChannel({ page: "preview" });
  addons.setChannel(channel);
  let clientApi = ((_a = scope) == null ? void 0 : _a.__STORYBOOK_CLIENT_API__) || new ClientApi(), preview = ((_b = scope) == null ? void 0 : _b.__STORYBOOK_PREVIEW__) || new PreviewWeb(), initialized = false, importFn = (path) => clientApi.importFn(path);
  function onStoriesChanged() {
    let storyIndex = clientApi.getStoryIndex();
    preview.onStoriesChanged({ storyIndex, importFn });
  }
  return clientApi.onImportFnChanged = onStoriesChanged, clientApi.storyStore = preview.storyStore, scope && (scope.__STORYBOOK_CLIENT_API__ = clientApi, scope.__STORYBOOK_ADDONS_CHANNEL__ = channel, scope.__STORYBOOK_PREVIEW__ = preview, scope.__STORYBOOK_STORY_STORE__ = preview.storyStore), { forceReRender: () => channel.emit(FORCE_RE_RENDER), clientApi, configure(framework, loadable, m, disableBackwardCompatibility = true) {
    if (disableBackwardCompatibility)
      throw new Error("unexpected configure() call");
    clientApi.addParameters({ framework });
    let getProjectAnnotations = () => {
      let { added, removed } = executeLoadableForChanges(loadable, m);
      return clientApi._loadAddedExports(), Array.from(added.entries()).forEach(([fileName, fileExports]) => clientApi.facade.addStoriesFromExports(fileName, fileExports)), Array.from(removed.entries()).forEach(([fileName]) => clientApi.facade.clearFilenameExports(fileName)), { render, ...clientApi.facade.projectAnnotations, renderToCanvas, applyDecorators: decorateStory2 };
    };
    initialized ? (getProjectAnnotations(), onStoriesChanged()) : (preview.initialize({ getStoryIndex: () => clientApi.getStoryIndex(), importFn, getProjectAnnotations }), initialized = true);
  } };
}

export {
  dequal,
  sanitizeStoryContextUpdate,
  prepareMeta,
  filterArgTypes,
  composeConfigs,
  Preview,
  DocsContext,
  start
};
//# sourceMappingURL=chunk-BJ3JU4R7.js.map
