import {
  require_synchronous_promise
} from "./chunk-BO3R2ZPC.js";
import {
  require_slash
} from "./chunk-V27W47CK.js";
import {
  require_mapValues
} from "./chunk-AE6N56OT.js";
import {
  require_pick
} from "./chunk-NEVMD4ST.js";
import {
  require_pickBy
} from "./chunk-NGQPZQN3.js";
import {
  require_isPlainObject
} from "./chunk-5JZSDNMO.js";
import {
  dedent,
  esm_default
} from "./chunk-DKITWJI6.js";
import {
  require_browser
} from "./chunk-2ZW4L6ZT.js";
import {
  createChannel
} from "./chunk-ZI7T7YNG.js";
import {
  require_lib
} from "./chunk-6JUMOWIJ.js";
import {
  scope
} from "./chunk-CWO6CHOE.js";
import {
  require_memoizerific
} from "./chunk-K2QDYCNL.js";
import {
  require_dist
} from "./chunk-4QHP5QJC.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@storybook/preview-api/node_modules/@storybook/channels/dist/index.mjs
var generateRandomId = () => Math.random().toString(16).slice(2);
var Channel = class {
  constructor({ transport, async = false } = {}) {
    this.sender = generateRandomId();
    this.events = {};
    this.data = {};
    this.transport = void 0;
    this.isAsync = async, transport && (this.transport = transport, this.transport.setHandler((event) => this.handleEvent(event)));
  }
  get hasTransport() {
    return !!this.transport;
  }
  addListener(eventName, listener) {
    this.events[eventName] = this.events[eventName] || [], this.events[eventName].push(listener);
  }
  emit(eventName, ...args) {
    let event = { type: eventName, args, from: this.sender }, options = {};
    args.length >= 1 && args[0] && args[0].options && (options = args[0].options);
    let handler = () => {
      this.transport && this.transport.send(event, options), this.handleEvent(event);
    };
    this.isAsync ? setImmediate(handler) : handler();
  }
  last(eventName) {
    return this.data[eventName];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(eventName) {
    let listeners = this.listeners(eventName);
    return listeners ? listeners.length : 0;
  }
  listeners(eventName) {
    return this.events[eventName] || void 0;
  }
  once(eventName, listener) {
    let onceListener = this.onceListener(eventName, listener);
    this.addListener(eventName, onceListener);
  }
  removeAllListeners(eventName) {
    eventName ? this.events[eventName] && delete this.events[eventName] : this.events = {};
  }
  removeListener(eventName, listener) {
    let listeners = this.listeners(eventName);
    listeners && (this.events[eventName] = listeners.filter((l) => l !== listener));
  }
  on(eventName, listener) {
    this.addListener(eventName, listener);
  }
  off(eventName, listener) {
    this.removeListener(eventName, listener);
  }
  handleEvent(event) {
    let listeners = this.listeners(event.type);
    listeners && listeners.length && listeners.forEach((fn) => {
      fn.apply(event, event.args);
    }), this.data[event.type] = event.args;
  }
  onceListener(eventName, listener) {
    let onceListener = (...args) => (this.removeListener(eventName, onceListener), listener(...args));
    return onceListener;
  }
};

// node_modules/@storybook/preview-api/node_modules/@storybook/client-logger/dist/index.mjs
var { LOGLEVEL } = scope;
var levels = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 };
var currentLogLevelString = LOGLEVEL;
var currentLogLevelNumber = levels[currentLogLevelString] || levels.info;
var logger = { trace: (message, ...rest) => {
  currentLogLevelNumber <= levels.trace && console.trace(message, ...rest);
}, debug: (message, ...rest) => {
  currentLogLevelNumber <= levels.debug && console.debug(message, ...rest);
}, info: (message, ...rest) => {
  currentLogLevelNumber <= levels.info && console.info(message, ...rest);
}, warn: (message, ...rest) => {
  currentLogLevelNumber <= levels.warn && console.warn(message, ...rest);
}, error: (message, ...rest) => {
  currentLogLevelNumber <= levels.error && console.error(message, ...rest);
}, log: (message, ...rest) => {
  currentLogLevelNumber < levels.silent && console.log(message, ...rest);
} };
var logged = /* @__PURE__ */ new Set();
var once = (type) => (message, ...rest) => {
  if (!logged.has(message))
    return logged.add(message), logger[type](message, ...rest);
};
once.clear = () => logged.clear();
once.trace = once("trace");
once.debug = once("debug");
once.info = once("info");
once.warn = once("warn");
once.error = once("error");
once.log = once("log");
var deprecate = once("warn");
var pretty = (type) => (...args) => {
  let argArray = [];
  if (args.length) {
    let startTagRe = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, endTagRe = /<\/span>/gi, reResultArray;
    for (argArray.push(args[0].replace(startTagRe, "%c").replace(endTagRe, "%c")); reResultArray = startTagRe.exec(args[0]); )
      argArray.push(reResultArray[2]), argArray.push("");
    for (let j = 1; j < args.length; j++)
      argArray.push(args[j]);
  }
  logger[type].apply(logger, argArray);
};
pretty.trace = pretty("trace");
pretty.debug = pretty("debug");
pretty.info = pretty("info");
pretty.warn = pretty("warn");
pretty.error = pretty("error");

// node_modules/@storybook/preview-api/node_modules/@storybook/core-events/dist/index.mjs
var events = ((events2) => (events2.CHANNEL_CREATED = "channelCreated", events2.CONFIG_ERROR = "configError", events2.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", events2.STORY_SPECIFIED = "storySpecified", events2.SET_CONFIG = "setConfig", events2.SET_STORIES = "setStories", events2.SET_INDEX = "setIndex", events2.SET_CURRENT_STORY = "setCurrentStory", events2.CURRENT_STORY_WAS_SET = "currentStoryWasSet", events2.FORCE_RE_RENDER = "forceReRender", events2.FORCE_REMOUNT = "forceRemount", events2.PRELOAD_ENTRIES = "preloadStories", events2.STORY_PREPARED = "storyPrepared", events2.STORY_CHANGED = "storyChanged", events2.STORY_UNCHANGED = "storyUnchanged", events2.STORY_RENDERED = "storyRendered", events2.STORY_MISSING = "storyMissing", events2.STORY_ERRORED = "storyErrored", events2.STORY_THREW_EXCEPTION = "storyThrewException", events2.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", events2.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", events2.UPDATE_STORY_ARGS = "updateStoryArgs", events2.STORY_ARGS_UPDATED = "storyArgsUpdated", events2.RESET_STORY_ARGS = "resetStoryArgs", events2.SET_GLOBALS = "setGlobals", events2.UPDATE_GLOBALS = "updateGlobals", events2.GLOBALS_UPDATED = "globalsUpdated", events2.REGISTER_SUBSCRIPTION = "registerSubscription", events2.PREVIEW_KEYDOWN = "previewKeydown", events2.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", events2.SELECT_STORY = "selectStory", events2.STORIES_COLLAPSE_ALL = "storiesCollapseAll", events2.STORIES_EXPAND_ALL = "storiesExpandAll", events2.DOCS_RENDERED = "docsRendered", events2.SHARED_STATE_CHANGED = "sharedStateChanged", events2.SHARED_STATE_SET = "sharedStateSet", events2.NAVIGATE_URL = "navigateUrl", events2.UPDATE_QUERY_PARAMS = "updateQueryParams", events2))(events || {});
var { CHANNEL_CREATED, CONFIG_ERROR, CURRENT_STORY_WAS_SET, DOCS_RENDERED, FORCE_RE_RENDER, FORCE_REMOUNT, GLOBALS_UPDATED, NAVIGATE_URL, PLAY_FUNCTION_THREW_EXCEPTION, PRELOAD_ENTRIES, PREVIEW_BUILDER_PROGRESS, PREVIEW_KEYDOWN, REGISTER_SUBSCRIPTION, RESET_STORY_ARGS, SELECT_STORY, SET_CONFIG, SET_CURRENT_STORY, SET_GLOBALS, SET_INDEX, SET_STORIES, SHARED_STATE_CHANGED, SHARED_STATE_SET, STORIES_COLLAPSE_ALL, STORIES_EXPAND_ALL, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_INDEX_INVALIDATED, STORY_MISSING, STORY_PREPARED, STORY_RENDER_PHASE_CHANGED, STORY_RENDERED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, UPDATE_GLOBALS, UPDATE_QUERY_PARAMS, UPDATE_STORY_ARGS } = events;
var IGNORED_EXCEPTION = new Error("ignoredException");

// node_modules/@storybook/preview-api/dist/chunk-RTGEOU4B.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
function mockChannel() {
  let transport = { setHandler: () => {
  }, send: () => {
  } };
  return new Channel({ transport });
}
var AddonStore = class {
  constructor() {
    this.getChannel = () => {
      if (!this.channel) {
        let channel = mockChannel();
        return this.setChannel(channel), channel;
      }
      return this.channel;
    };
    this.getServerChannel = () => {
      if (!this.serverChannel)
        throw new Error("Accessing non-existent serverChannel");
      return this.serverChannel;
    };
    this.ready = () => this.promise;
    this.hasChannel = () => !!this.channel;
    this.hasServerChannel = () => !!this.serverChannel;
    this.setChannel = (channel) => {
      this.channel = channel, this.resolve();
    };
    this.setServerChannel = (channel) => {
      this.serverChannel = channel;
    };
    this.promise = new Promise((res) => {
      this.resolve = () => res(this.getChannel());
    });
  }
};
var KEY = "__STORYBOOK_ADDONS_PREVIEW";
function getAddonsStore() {
  return scope[KEY] || (scope[KEY] = new AddonStore()), scope[KEY];
}
var addons = getAddonsStore();
var HooksContext = class {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = (storyId) => {
      var _a;
      storyId === ((_a = this.currentContext) == null ? void 0 : _a.id) && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    };
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = this.mountedDecorators, this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((effect) => {
      effect.destroy && effect.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let hook = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, hook;
  }
  triggerEffects() {
    this.prevEffects.forEach((effect) => {
      !this.currentEffects.includes(effect) && effect.destroy && effect.destroy();
    }), this.currentEffects.forEach((effect) => {
      this.prevEffects.includes(effect) || (effect.destroy = effect.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), addons.getChannel().on(STORY_RENDERED, this.renderListener);
  }
  removeRenderListeners() {
    addons.getChannel().removeListener(STORY_RENDERED, this.renderListener);
  }
};
function hookify(fn) {
  return (...args) => {
    let { hooks } = typeof args[0] == "function" ? args[1] : args[0], prevPhase = hooks.currentPhase, prevHooks = hooks.currentHooks, prevNextHookIndex = hooks.nextHookIndex, prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn.name, hooks.prevMountedDecorators.has(fn) ? (hooks.currentPhase = "UPDATE", hooks.currentHooks = hooks.hookListsMap.get(fn) || []) : (hooks.currentPhase = "MOUNT", hooks.currentHooks = [], hooks.hookListsMap.set(fn, hooks.currentHooks), hooks.prevMountedDecorators.add(fn)), hooks.nextHookIndex = 0;
    let prevContext = scope.STORYBOOK_HOOKS_CONTEXT;
    scope.STORYBOOK_HOOKS_CONTEXT = hooks;
    let result = fn(...args);
    if (scope.STORYBOOK_HOOKS_CONTEXT = prevContext, hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null)
      throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    return hooks.currentPhase = prevPhase, hooks.currentHooks = prevHooks, hooks.nextHookIndex = prevNextHookIndex, hooks.currentDecoratorName = prevDecoratorName, result;
  };
}
var numberOfRenders = 0;
var RENDER_LIMIT = 25;
var applyHooks = (applyDecorators) => (storyFn, decorators) => {
  let decorated = applyDecorators(hookify(storyFn), decorators.map((decorator) => hookify(decorator)));
  return (context) => {
    let { hooks } = context;
    hooks.prevMountedDecorators = hooks.mountedDecorators, hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators]), hooks.currentContext = context, hooks.hasUpdates = false;
    let result = decorated(context);
    for (numberOfRenders = 1; hooks.hasUpdates; )
      if (hooks.hasUpdates = false, hooks.currentEffects = [], result = decorated(context), numberOfRenders += 1, numberOfRenders > RENDER_LIMIT)
        throw new Error("Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.");
    return hooks.addRenderListeners(), result;
  };
};

// node_modules/@storybook/preview-api/dist/chunk-QTGABOHS.mjs
var import_memoizerific = __toESM(require_memoizerific(), 1);
var import_mapValues = __toESM(require_mapValues(), 1);
var import_pick = __toESM(require_pick(), 1);
var import_synchronous_promise = __toESM(require_synchronous_promise(), 1);
var import_memoizerific2 = __toESM(require_memoizerific(), 1);

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/@storybook/preview-api/dist/chunk-QTGABOHS.mjs
var import_isPlainObject = __toESM(require_isPlainObject(), 1);
var import_mapValues2 = __toESM(require_mapValues(), 1);
var import_csf = __toESM(require_dist(), 1);
var import_util_deprecate = __toESM(require_browser(), 1);
var import_csf2 = __toESM(require_dist(), 1);
var import_csf3 = __toESM(require_dist(), 1);
var import_csf4 = __toESM(require_dist(), 1);
var import_isPlainObject2 = __toESM(require_isPlainObject(), 1);
var import_mapValues3 = __toESM(require_mapValues(), 1);
var import_mapValues4 = __toESM(require_mapValues(), 1);
var import_pickBy = __toESM(require_pickBy(), 1);
var import_csf5 = __toESM(require_dist(), 1);
var import_slash = __toESM(require_slash(), 1);
var getImportPathMap = (0, import_memoizerific2.default)(1)((entries) => Object.values(entries).reduce((acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc), {}));
var StoryIndexStore = class {
  constructor({ entries } = { v: 4, entries: {} }) {
    this.entries = entries;
  }
  entryFromSpecifier(specifier) {
    let entries = Object.values(this.entries);
    if (specifier === "*")
      return entries[0];
    if (typeof specifier == "string")
      return this.entries[specifier] ? this.entries[specifier] : entries.find((entry) => entry.id.startsWith(specifier));
    let { name, title } = specifier;
    return entries.find((entry) => entry.name === name && entry.title === title);
  }
  storyIdToEntry(storyId) {
    let storyEntry = this.entries[storyId];
    if (!storyEntry)
      throw new Error(dedent`Couldn't find story matching '${storyId}' after HMR.
      - Did you remove it from your CSF file?
      - Are you sure a story with that id exists?
      - Please check your entries field of your main.js config.
      - Also check the browser console and terminal for error messages.`);
    return storyEntry;
  }
  importPathToEntry(importPath) {
    return getImportPathMap(this.entries)[importPath];
  }
};
var INCOMPATIBLE = Symbol("incompatible");
var map = (arg, argType) => {
  let type = argType.type;
  if (arg == null || !type || argType.mapping)
    return arg;
  switch (type.name) {
    case "string":
      return String(arg);
    case "enum":
      return arg;
    case "number":
      return Number(arg);
    case "boolean":
      return arg === "true";
    case "array":
      return !type.value || !Array.isArray(arg) ? INCOMPATIBLE : arg.reduce((acc, item, index) => {
        let mapped = map(item, { type: type.value });
        return mapped !== INCOMPATIBLE && (acc[index] = mapped), acc;
      }, new Array(arg.length));
    case "object":
      return typeof arg == "string" || typeof arg == "number" ? arg : !type.value || typeof arg != "object" ? INCOMPATIBLE : Object.entries(arg).reduce((acc, [key, val]) => {
        let mapped = map(val, { type: type.value[key] });
        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
      }, {});
    default:
      return INCOMPATIBLE;
  }
};
var mapArgsToTypes = (args, argTypes) => Object.entries(args).reduce((acc, [key, value]) => {
  if (!argTypes[key])
    return acc;
  let mapped = map(value, argTypes[key]);
  return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
}, {});
var combineArgs = (value, update) => Array.isArray(value) && Array.isArray(update) ? update.reduce((acc, upd, index) => (acc[index] = combineArgs(value[index], update[index]), acc), [...value]).filter((v) => v !== void 0) : !(0, import_isPlainObject.default)(value) || !(0, import_isPlainObject.default)(update) ? update : Object.keys({ ...value, ...update }).reduce((acc, key) => {
  if (key in update) {
    let combined = combineArgs(value[key], update[key]);
    combined !== void 0 && (acc[key] = combined);
  } else
    acc[key] = value[key];
  return acc;
}, {});
var validateOptions = (args, argTypes) => Object.entries(argTypes).reduce((acc, [key, { options }]) => {
  function allowArg() {
    return key in args && (acc[key] = args[key]), acc;
  }
  if (!options)
    return allowArg();
  if (!Array.isArray(options))
    return once.error(dedent`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/react/api/argtypes
      `), allowArg();
  if (options.some((opt) => opt && ["object", "function"].includes(typeof opt)))
    return once.error(dedent`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
      `), allowArg();
  let isArray = Array.isArray(args[key]), invalidIndex = isArray && args[key].findIndex((val) => !options.includes(val)), isValidArray = isArray && invalidIndex === -1;
  if (args[key] === void 0 || options.includes(args[key]) || isValidArray)
    return allowArg();
  let field = isArray ? `${key}[${invalidIndex}]` : key, supportedOptions = options.map((opt) => typeof opt == "string" ? `'${opt}'` : String(opt)).join(", ");
  return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`), acc;
}, {});
var DEEPLY_EQUAL = Symbol("Deeply equal");
var deepDiff = (value, update) => {
  if (typeof value != typeof update)
    return update;
  if (dequal(value, update))
    return DEEPLY_EQUAL;
  if (Array.isArray(value) && Array.isArray(update)) {
    let res = update.reduce((acc, upd, index) => {
      let diff = deepDiff(value[index], upd);
      return diff !== DEEPLY_EQUAL && (acc[index] = diff), acc;
    }, new Array(update.length));
    return update.length >= value.length ? res : res.concat(new Array(value.length - update.length).fill(void 0));
  }
  return (0, import_isPlainObject.default)(value) && (0, import_isPlainObject.default)(update) ? Object.keys({ ...value, ...update }).reduce((acc, key) => {
    let diff = deepDiff(value == null ? void 0 : value[key], update == null ? void 0 : update[key]);
    return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff });
  }, {}) : update;
};
var UNTARGETED = "UNTARGETED";
function groupArgsByTarget({ args, argTypes }) {
  let groupedArgs = {};
  return Object.entries(args).forEach(([name, value]) => {
    let { target = UNTARGETED } = argTypes[name] || {};
    groupedArgs[target] = groupedArgs[target] || {}, groupedArgs[target][name] = value;
  }), groupedArgs;
}
function deleteUndefined(obj) {
  return Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]), obj;
}
var ArgsStore = class {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(storyId) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    return this.argsByStoryId[storyId];
  }
  setInitial(story) {
    if (!this.initialArgsByStoryId[story.id])
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs;
    else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
      let delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs, delta !== DEEPLY_EQUAL && this.updateFromDelta(story, delta);
    }
  }
  updateFromDelta(story, delta) {
    let validatedDelta = validateOptions(delta, story.argTypes);
    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
  }
  updateFromPersisted(story, persisted) {
    let mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
    return this.updateFromDelta(story, mappedPersisted);
  }
  update(storyId, argsUpdate) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    this.argsByStoryId[storyId] = deleteUndefined({ ...this.argsByStoryId[storyId], ...argsUpdate });
  }
};
var getValuesFromArgTypes = (argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => (typeof defaultValue < "u" && (acc[arg] = defaultValue), acc), {});
var GlobalsStore = class {
  constructor({ globals = {}, globalTypes = {} }) {
    this.set({ globals, globalTypes });
  }
  set({ globals = {}, globalTypes = {} }) {
    let delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
    let defaultGlobals = getValuesFromArgTypes(globalTypes);
    this.initialGlobals = { ...defaultGlobals, ...globals }, this.globals = this.initialGlobals, delta && delta !== DEEPLY_EQUAL && this.updateFromPersisted(delta);
  }
  filterAllowedGlobals(globals) {
    return Object.entries(globals).reduce((acc, [key, value]) => (this.allowedGlobalNames.has(key) ? acc[key] = value : logger.warn(`Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`), acc), {});
  }
  updateFromPersisted(persisted) {
    let allowedUrlGlobals = this.filterAllowedGlobals(persisted);
    this.globals = { ...this.globals, ...allowedUrlGlobals };
  }
  get() {
    return this.globals;
  }
  update(newGlobals) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
  }
};
var normalizeType = (type) => typeof type == "string" ? { name: type } : type;
var normalizeControl = (control) => typeof control == "string" ? { type: control } : control;
var normalizeInputType = (inputType, key) => {
  let { type, control, ...rest } = inputType, normalized = { name: key, ...rest };
  return type && (normalized.type = normalizeType(type)), control ? normalized.control = normalizeControl(control) : control === false && (normalized.control = { disable: true }), normalized;
};
var normalizeInputTypes = (inputTypes) => (0, import_mapValues2.default)(inputTypes, normalizeInputType);
var deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
var deprecatedStoryAnnotationWarning = (0, import_util_deprecate.default)(() => {
}, deprecatedStoryAnnotation);
function normalizeStory(key, storyAnnotations, meta) {
  let storyObject = storyAnnotations, userStoryFn = typeof storyAnnotations == "function" ? storyAnnotations : null, { story } = storyObject;
  story && (logger.debug("deprecated story", story), deprecatedStoryAnnotationWarning());
  let exportName = (0, import_csf.storyNameFromExport)(key), name = typeof storyObject != "function" && storyObject.name || storyObject.storyName || (story == null ? void 0 : story.name) || exportName, decorators = [...storyObject.decorators || [], ...(story == null ? void 0 : story.decorators) || []], parameters = { ...story == null ? void 0 : story.parameters, ...storyObject.parameters }, args = { ...story == null ? void 0 : story.args, ...storyObject.args }, argTypes = { ...story == null ? void 0 : story.argTypes, ...storyObject.argTypes }, loaders = [...storyObject.loaders || [], ...(story == null ? void 0 : story.loaders) || []], { render, play, tags = [] } = storyObject, id = parameters.__id || (0, import_csf.toId)(meta.id, exportName);
  return { moduleExport: storyAnnotations, id, name, tags, decorators, parameters, args, argTypes: normalizeInputTypes(argTypes), loaders, ...render && { render }, ...userStoryFn && { userStoryFn }, ...play && { play } };
}
function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
  let { id, argTypes } = defaultExport;
  return { id: (0, import_csf3.sanitize)(id || title), ...defaultExport, title, ...argTypes && { argTypes: normalizeInputTypes(argTypes) }, parameters: { fileName: importPath, ...defaultExport.parameters } };
}
var checkGlobals = (parameters) => {
  let { globals, globalTypes } = parameters;
  (globals || globalTypes) && logger.error("Global args/argTypes can only be set globally", JSON.stringify({ globals, globalTypes }));
};
var checkStorySort = (parameters) => {
  let { options } = parameters;
  (options == null ? void 0 : options.storySort) && logger.error("The storySort option parameter can only be set globally");
};
var checkDisallowedParameters = (parameters) => {
  parameters && (checkGlobals(parameters), checkStorySort(parameters));
};
var checkSubcomponents = (meta) => {
  meta.subcomponents && deprecate(esm_default`The \`subcomponents\` annotation is deprecated. 
    
      Please refer to the migration guide: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#argstable-block'
    `);
};
function processCSFFile(moduleExports, importPath, title) {
  let { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports, meta = normalizeComponentAnnotations(defaultExport, title, importPath);
  checkDisallowedParameters(meta.parameters), checkSubcomponents(meta);
  let csfFile = { meta, stories: {}, moduleExports };
  return Object.keys(namedExports).forEach((key) => {
    if ((0, import_csf2.isExportStory)(key, meta)) {
      let storyMeta = normalizeStory(key, namedExports[key], meta);
      checkDisallowedParameters(storyMeta.parameters), csfFile.stories[storyMeta.id] = storyMeta;
    }
  }), csfFile;
}
var combineParameters = (...parameterSets) => {
  let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters) => (Object.entries(parameters).forEach(([key, value]) => {
    let existing = acc[key];
    Array.isArray(value) || typeof existing > "u" ? acc[key] = value : (0, import_isPlainObject2.default)(value) && (0, import_isPlainObject2.default)(existing) ? mergeKeys[key] = true : typeof value < "u" && (acc[key] = value);
  }), acc), {});
  return Object.keys(mergeKeys).forEach((key) => {
    let mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key]).filter((value) => typeof value < "u");
    mergeValues.every((value) => (0, import_isPlainObject2.default)(value)) ? combined[key] = combineParameters(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];
  }), combined;
};
function decorateStory(storyFn, decorator, bindWithContext) {
  let boundStoryFunction = bindWithContext(storyFn);
  return (context) => decorator(boundStoryFunction, context);
}
function sanitizeStoryContextUpdate({ componentId, title, kind, id, name, story, parameters, initialArgs, argTypes, ...update } = {}) {
  return update;
}
function defaultDecorateStory(storyFn, decorators) {
  let contextStore = {}, bindWithContext = (decoratedStoryFn) => (update) => {
    if (!contextStore.value)
      throw new Error("Decorated function called without init");
    return contextStore.value = { ...contextStore.value, ...sanitizeStoryContextUpdate(update) }, decoratedStoryFn(contextStore.value);
  }, decoratedWithContextStore = decorators.reduce((story, decorator) => decorateStory(story, decorator, bindWithContext), storyFn);
  return (context) => (contextStore.value = context, decoratedWithContextStore(context));
}
function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
  let { moduleExport, id, name } = storyAnnotations || {}, partialAnnotations = preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations), loaders = [...projectAnnotations.loaders || [], ...componentAnnotations.loaders || [], ...(storyAnnotations == null ? void 0 : storyAnnotations.loaders) || []], applyLoaders = async (context) => {
    let loadResults = await Promise.all(loaders.map((loader) => loader(context))), loaded = Object.assign({}, ...loadResults);
    return { ...context, loaded };
  }, undecoratedStoryFn = (context) => {
    let { passArgsFirst: renderTimePassArgsFirst = true } = context.parameters;
    return renderTimePassArgsFirst ? render(context.args, context) : render(context);
  }, { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations, decorators = [...(storyAnnotations == null ? void 0 : storyAnnotations.decorators) || [], ...componentAnnotations.decorators || [], ...projectAnnotations.decorators || []], render = (storyAnnotations == null ? void 0 : storyAnnotations.userStoryFn) || (storyAnnotations == null ? void 0 : storyAnnotations.render) || componentAnnotations.render || projectAnnotations.render;
  if (!render)
    throw new Error(`No render function available for storyId '${id}'`);
  let decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators), unboundStoryFn = (context) => decoratedStoryFn(context), prepareContext = (context) => {
    var _a;
    let finalContext = context;
    if ((_a = scope.FEATURES) == null ? void 0 : _a.argTypeTargetsV7) {
      let argsByTarget = groupArgsByTarget(context);
      finalContext = { ...context, allArgs: context.args, argsByTarget, args: argsByTarget[UNTARGETED] || {} };
    }
    let mappedArgs = Object.entries(finalContext.args).reduce((acc, [key, val]) => {
      var _a2;
      let mapping = (_a2 = finalContext.argTypes[key]) == null ? void 0 : _a2.mapping;
      return acc[key] = mapping && val in mapping ? mapping[val] : val, acc;
    }, {}), includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
      let argType = finalContext.argTypes[key] || {};
      return (0, import_csf4.includeConditionalArg)(argType, mappedArgs, finalContext.globals) && (acc[key] = val), acc;
    }, {});
    return { ...finalContext, args: includedArgs };
  }, play = (storyAnnotations == null ? void 0 : storyAnnotations.play) || componentAnnotations.play;
  return { ...partialAnnotations, moduleExport, id, name, story: name, originalStoryFn: render, undecoratedStoryFn, unboundStoryFn, applyLoaders, playFunction: play && (async (storyContext) => {
    let playFunctionContext = { ...storyContext, step: (label, play2) => runStep(label, play2, playFunctionContext) };
    return play(playFunctionContext);
  }), prepareContext };
}
function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
  return { ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations), moduleExport };
}
function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
  var _a;
  let id = (storyAnnotations == null ? void 0 : storyAnnotations.id) || componentAnnotations.id, tags = [...(storyAnnotations == null ? void 0 : storyAnnotations.tags) || componentAnnotations.tags || [], "story"], parameters = combineParameters(projectAnnotations.parameters, componentAnnotations.parameters, storyAnnotations == null ? void 0 : storyAnnotations.parameters), { argTypesEnhancers = [], argsEnhancers = [] } = projectAnnotations, render = (storyAnnotations == null ? void 0 : storyAnnotations.userStoryFn) || (storyAnnotations == null ? void 0 : storyAnnotations.render) || componentAnnotations.render || projectAnnotations.render;
  if (!render)
    throw new Error(`No render function available for id '${id}'`);
  let passedArgTypes = combineParameters(projectAnnotations.argTypes, componentAnnotations.argTypes, storyAnnotations == null ? void 0 : storyAnnotations.argTypes), { passArgsFirst = true } = parameters;
  parameters.__isArgsStory = passArgsFirst && render.length > 0;
  let passedArgs = { ...projectAnnotations.args, ...componentAnnotations.args, ...storyAnnotations == null ? void 0 : storyAnnotations.args }, contextForEnhancers = { componentId: componentAnnotations.id, title: componentAnnotations.title, kind: componentAnnotations.title, id: (storyAnnotations == null ? void 0 : storyAnnotations.id) || componentAnnotations.id, name: (storyAnnotations == null ? void 0 : storyAnnotations.name) || "__meta", story: (storyAnnotations == null ? void 0 : storyAnnotations.name) || "__meta", component: componentAnnotations.component, subcomponents: componentAnnotations.subcomponents, tags, parameters, initialArgs: passedArgs, argTypes: passedArgTypes };
  contextForEnhancers.argTypes = argTypesEnhancers.reduce((accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }), contextForEnhancers.argTypes);
  let initialArgsBeforeEnhancers = { ...passedArgs };
  contextForEnhancers.initialArgs = argsEnhancers.reduce((accumulatedArgs, enhancer) => ({ ...accumulatedArgs, ...enhancer({ ...contextForEnhancers, initialArgs: accumulatedArgs }) }), initialArgsBeforeEnhancers), ((_a = scope.FEATURES) == null ? void 0 : _a.breakingChangesV7) || (contextForEnhancers.parameters = { ...contextForEnhancers.parameters, __id: id, globals: projectAnnotations.globals, globalTypes: projectAnnotations.globalTypes, args: contextForEnhancers.initialArgs, argTypes: contextForEnhancers.argTypes });
  let { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;
  return withoutStoryIdentifiers;
}
var inferType = (value, name, visited) => {
  let type = typeof value;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: type };
    default:
      break;
  }
  return value ? visited.has(value) ? (logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (visited.add(value), Array.isArray(value) ? { name: "array", value: value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: "other", value: "unknown" } } : { name: "object", value: (0, import_mapValues3.default)(value, (field) => inferType(field, name, new Set(visited))) }) : { name: "object", value: {} };
};
var inferArgTypes = (context) => {
  let { id, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = (0, import_mapValues3.default)(initialArgs, (arg, key) => ({ name: key, type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set()) })), userArgTypesNames = (0, import_mapValues3.default)(userArgTypes, (argType, key) => ({ name: key }));
  return combineParameters(argTypes, userArgTypesNames, userArgTypes);
};
inferArgTypes.secondPass = true;
var matches = (name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor);
var filterArgTypes = (argTypes, include, exclude) => !include && !exclude ? argTypes : argTypes && (0, import_pickBy.default)(argTypes, (argType, key) => {
  let name = argType.name || key;
  return (!include || matches(name, include)) && (!exclude || !matches(name, exclude));
});
var inferControl = (argType, name, matchers) => {
  let { type, options } = argType;
  if (type) {
    if (matchers.color && matchers.color.test(name)) {
      let controlType = type.name;
      if (controlType === "string")
        return { control: { type: "color" } };
      controlType !== "enum" && logger.warn(`Addon controls: Control of type color only supports string, received "${controlType}" instead`);
    }
    if (matchers.date && matchers.date.test(name))
      return { control: { type: "date" } };
    switch (type.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value } = type;
        return { control: { type: (value == null ? void 0 : value.length) <= 5 ? "radio" : "select" }, options: value };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: options ? "select" : "object" } };
    }
  }
};
var inferControls = (context) => {
  let { argTypes, parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} } } = context;
  if (!__isArgsStory)
    return argTypes;
  let filteredArgTypes = filterArgTypes(argTypes, include, exclude), withControls = (0, import_mapValues4.default)(filteredArgTypes, (argType, name) => (argType == null ? void 0 : argType.type) && inferControl(argType, name, matchers));
  return combineParameters(withControls, filteredArgTypes);
};
inferControls.secondPass = true;
function normalizeProjectAnnotations({ argTypes, globalTypes, argTypesEnhancers, ...annotations }) {
  return { ...argTypes && { argTypes: normalizeInputTypes(argTypes) }, ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) }, argTypesEnhancers: [...argTypesEnhancers || [], inferArgTypes, inferControls], ...annotations };
}
function composeStepRunners(stepRunners) {
  return async (label, play, playContext) => {
    await stepRunners.reduceRight((innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext), async () => play(playContext))();
  };
}
function getField(moduleExportList, field) {
  return moduleExportList.map((xs) => xs[field]).filter(Boolean);
}
function getArrayField(moduleExportList, field) {
  return getField(moduleExportList, field).reduce((a, b) => [...a, ...b], []);
}
function getObjectField(moduleExportList, field) {
  return Object.assign({}, ...getField(moduleExportList, field));
}
function getSingletonField(moduleExportList, field) {
  return getField(moduleExportList, field).pop();
}
function composeConfigs(moduleExportList) {
  let allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers"), stepRunners = getField(moduleExportList, "runStep");
  return { parameters: combineParameters(...getField(moduleExportList, "parameters")), decorators: getArrayField(moduleExportList, "decorators"), args: getObjectField(moduleExportList, "args"), argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"), argTypes: getObjectField(moduleExportList, "argTypes"), argTypesEnhancers: [...allArgTypeEnhancers.filter((e) => !e.secondPass), ...allArgTypeEnhancers.filter((e) => e.secondPass)], globals: getObjectField(moduleExportList, "globals"), globalTypes: getObjectField(moduleExportList, "globalTypes"), loaders: getArrayField(moduleExportList, "loaders"), render: getSingletonField(moduleExportList, "render"), renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"), renderToDOM: getSingletonField(moduleExportList, "renderToDOM"), applyDecorators: getSingletonField(moduleExportList, "applyDecorators"), runStep: composeStepRunners(stepRunners) };
}
var CSF_CACHE_SIZE = 1e3;
var STORY_CACHE_SIZE = 1e4;
var EXTRACT_BATCH_SIZE = 20;
var StoryStore = class {
  constructor() {
    this.getStoriesJsonData = () => {
      let { storyIndex } = this;
      if (!storyIndex)
        throw new Error("getStoriesJsonData called before initialization");
      let value = this.getSetStoriesPayload(), allowedParameters = ["fileName", "docsOnly", "framework", "__id", "__isArgsStory"];
      return { v: 3, stories: (0, import_mapValues.default)(value.stories, (story) => {
        let { importPath } = storyIndex.entries[story.id];
        return { ...(0, import_pick.default)(story, ["id", "name", "title"]), importPath, kind: story.title, story: story.name, parameters: { ...(0, import_pick.default)(story.parameters, allowedParameters), fileName: importPath } };
      }) };
    };
    this.args = new ArgsStore(), this.hooks = {}, this.processCSFFileWithCache = (0, import_memoizerific.default)(CSF_CACHE_SIZE)(processCSFFile), this.prepareStoryWithCache = (0, import_memoizerific.default)(STORY_CACHE_SIZE)(prepareStory), this.initializationPromise = new import_synchronous_promise.SynchronousPromise((resolve) => {
      this.resolveInitializationPromise = resolve;
    });
  }
  setProjectAnnotations(projectAnnotations) {
    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
    let { globals, globalTypes } = projectAnnotations;
    this.globals ? this.globals.set({ globals, globalTypes }) : this.globals = new GlobalsStore({ globals, globalTypes });
  }
  initialize({ storyIndex, importFn, cache = false }) {
    return this.storyIndex = new StoryIndexStore(storyIndex), this.importFn = importFn, this.resolveInitializationPromise(), cache ? this.cacheAllCSFFiles() : import_synchronous_promise.SynchronousPromise.resolve();
  }
  async onStoriesChanged({ importFn, storyIndex }) {
    await this.initializationPromise, importFn && (this.importFn = importFn), storyIndex && (this.storyIndex.entries = storyIndex.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  async storyIdToEntry(storyId) {
    return await this.initializationPromise, this.storyIndex.storyIdToEntry(storyId);
  }
  loadCSFFileByStoryId(storyId) {
    if (!this.storyIndex || !this.importFn)
      throw new Error("loadCSFFileByStoryId called before initialization");
    let { importPath, title } = this.storyIndex.storyIdToEntry(storyId);
    return this.importFn(importPath).then((moduleExports) => this.processCSFFileWithCache(moduleExports, importPath, title));
  }
  loadAllCSFFiles({ batchSize = EXTRACT_BATCH_SIZE } = {}) {
    if (!this.storyIndex)
      throw new Error("loadAllCSFFiles called before initialization");
    let importPaths = Object.entries(this.storyIndex.entries).map(([storyId, { importPath }]) => [importPath, storyId]), loadInBatches = (remainingImportPaths) => {
      if (remainingImportPaths.length === 0)
        return import_synchronous_promise.SynchronousPromise.resolve([]);
      let csfFilePromiseList = remainingImportPaths.slice(0, batchSize).map(([importPath, storyId]) => this.loadCSFFileByStoryId(storyId).then((csfFile) => ({ importPath, csfFile })));
      return import_synchronous_promise.SynchronousPromise.all(csfFilePromiseList).then((firstResults) => loadInBatches(remainingImportPaths.slice(batchSize)).then((restResults) => firstResults.concat(restResults)));
    };
    return loadInBatches(importPaths).then((list) => list.reduce((acc, { importPath, csfFile }) => (acc[importPath] = csfFile, acc), {}));
  }
  cacheAllCSFFiles() {
    return this.initializationPromise.then(() => this.loadAllCSFFiles().then((csfFiles) => {
      this.cachedCSFFiles = csfFiles;
    }));
  }
  async loadStory({ storyId }) {
    await this.initializationPromise;
    let csfFile = await this.loadCSFFileByStoryId(storyId);
    return this.storyFromCSFFile({ storyId, csfFile });
  }
  storyFromCSFFile({ storyId, csfFile }) {
    if (!this.projectAnnotations)
      throw new Error("storyFromCSFFile called before initialization");
    let storyAnnotations = csfFile.stories[storyId];
    if (!storyAnnotations)
      throw new Error(`Didn't find '${storyId}' in CSF file, this is unexpected`);
    let componentAnnotations = csfFile.meta, story = this.prepareStoryWithCache(storyAnnotations, componentAnnotations, this.projectAnnotations);
    return this.args.setInitial(story), this.hooks[story.id] = this.hooks[story.id] || new HooksContext(), story;
  }
  componentStoriesFromCSFFile({ csfFile }) {
    if (!this.storyIndex)
      throw new Error("componentStoriesFromCSFFile called before initialization");
    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
  }
  async loadEntry(id) {
    let entry = await this.storyIdToEntry(id), { importFn, storyIndex } = this;
    if (!storyIndex || !importFn)
      throw new Error("loadEntry called before initialization");
    let storyImports = entry.type === "docs" ? entry.storiesImports : [], [entryExports, ...csfFiles] = await Promise.all([importFn(entry.importPath), ...storyImports.map((storyImportPath) => {
      let firstStoryEntry = storyIndex.importPathToEntry(storyImportPath);
      return this.loadCSFFileByStoryId(firstStoryEntry.id);
    })]);
    return { entryExports, csfFiles };
  }
  getStoryContext(story) {
    if (!this.globals)
      throw new Error("getStoryContext called before initialization");
    return { ...story, args: this.args.get(story.id), globals: this.globals.get(), hooks: this.hooks[story.id] };
  }
  cleanupStory(story) {
    this.hooks[story.id].clean();
  }
  extract(options = { includeDocsOnly: false }) {
    if (!this.storyIndex)
      throw new Error("extract called before initialization");
    let { cachedCSFFiles } = this;
    if (!cachedCSFFiles)
      throw new Error("Cannot call extract() unless you call cacheAllCSFFiles() first.");
    return Object.entries(this.storyIndex.entries).reduce((acc, [storyId, { type, importPath }]) => {
      if (type === "docs")
        return acc;
      let csfFile = cachedCSFFiles[importPath], story = this.storyFromCSFFile({ storyId, csfFile });
      return !options.includeDocsOnly && story.parameters.docsOnly || (acc[storyId] = Object.entries(story).reduce((storyAcc, [key, value]) => key === "moduleExport" || typeof value == "function" ? storyAcc : Array.isArray(value) ? Object.assign(storyAcc, { [key]: value.slice().sort() }) : Object.assign(storyAcc, { [key]: value }), { args: story.initialArgs })), acc;
    }, {});
  }
  getSetStoriesPayload() {
    if (!this.globals)
      throw new Error("getSetStoriesPayload called before initialization");
    let stories = this.extract({ includeDocsOnly: true }), kindParameters = Object.values(stories).reduce((acc, { title }) => (acc[title] = {}, acc), {});
    return { v: 2, globals: this.globals.get(), globalParameters: {}, kindParameters, stories };
  }
  getSetIndexPayload() {
    if (!this.storyIndex)
      throw new Error("getSetIndexPayload called before initialization");
    let stories = this.extract({ includeDocsOnly: true });
    return { v: 4, entries: Object.fromEntries(Object.entries(this.storyIndex.entries).map(([id, entry]) => [id, stories[id] ? { ...entry, args: stories[id].initialArgs, initialArgs: stories[id].initialArgs, argTypes: stories[id].argTypes, parameters: stories[id].parameters } : entry])) };
  }
  raw() {
    return Object.values(this.extract()).map(({ id }) => this.fromId(id)).filter(Boolean);
  }
  fromId(storyId) {
    if (!this.storyIndex)
      throw new Error("fromId called before initialization");
    if (!this.cachedCSFFiles)
      throw new Error("Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.");
    let importPath;
    try {
      ({ importPath } = this.storyIndex.storyIdToEntry(storyId));
    } catch {
      return null;
    }
    let csfFile = this.cachedCSFFiles[importPath], story = this.storyFromCSFFile({ storyId, csfFile });
    return { ...story, storyFn: (update) => {
      let context = { ...this.getStoryContext(story), viewMode: "story" };
      return story.unboundStoryFn({ ...context, ...update });
    } };
  }
};
var stripExtension = (path) => {
  let parts = [...path], last = parts[parts.length - 1], dotIndex = last.indexOf("."), stripped = dotIndex > 0 ? last.substr(0, dotIndex) : last;
  parts[parts.length - 1] = stripped;
  let [first, ...rest] = parts;
  return first === "" && (parts = rest), parts;
};
var indexRe = /^index$/i;
var removeRedundantFilename = (paths) => {
  let prevVal;
  return paths.filter((val, index) => index === paths.length - 1 && (val === prevVal || indexRe.test(val)) ? false : (prevVal = val, true));
};
function pathJoin(paths) {
  let slashes = new RegExp("/{1,}", "g");
  return paths.join("/").replace(slashes, "/");
}
var userOrAutoTitleFromSpecifier = (fileName, entry, userTitle) => {
  let { directory, importPathMatcher, titlePrefix = "" } = entry || {};
  typeof fileName == "number" && once.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let normalizedFileName = (0, import_slash.default)(String(fileName));
  if (importPathMatcher.exec(normalizedFileName)) {
    if (!userTitle) {
      let suffix = normalizedFileName.replace(directory, ""), path = (0, import_slash.default)(pathJoin([titlePrefix, suffix])).split("/");
      return path = stripExtension(path), path = removeRedundantFilename(path), path.join("/");
    }
    return titlePrefix ? (0, import_slash.default)(pathJoin([titlePrefix, userTitle])) : userTitle;
  }
};
var userOrAutoTitle = (fileName, storiesEntries, userTitle) => {
  for (let i = 0; i < storiesEntries.length; i += 1) {
    let title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i], userTitle);
    if (title)
      return title;
  }
  return userTitle || void 0;
};
var STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/;
var storySort = (options = {}) => (a, b) => {
  if (a.title === b.title && !options.includeNames)
    return 0;
  let method = options.method || "configure", order = options.order || [], storyTitleA = a.title.trim().split(STORY_KIND_PATH_SEPARATOR), storyTitleB = b.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  options.includeNames && (storyTitleA.push(a.name), storyTitleB.push(b.name));
  let depth = 0;
  for (; storyTitleA[depth] || storyTitleB[depth]; ) {
    if (!storyTitleA[depth])
      return -1;
    if (!storyTitleB[depth])
      return 1;
    let nameA = storyTitleA[depth], nameB = storyTitleB[depth];
    if (nameA !== nameB) {
      let indexA = order.indexOf(nameA), indexB = order.indexOf(nameB), indexWildcard = order.indexOf("*");
      return indexA !== -1 || indexB !== -1 ? (indexA === -1 && (indexWildcard !== -1 ? indexA = indexWildcard : indexA = order.length), indexB === -1 && (indexWildcard !== -1 ? indexB = indexWildcard : indexB = order.length), indexA - indexB) : method === "configure" ? 0 : nameA.localeCompare(nameB, options.locales ? options.locales : void 0, { numeric: true, sensitivity: "accent" });
    }
    let index = order.indexOf(nameA);
    index === -1 && (index = order.indexOf("*")), order = index !== -1 && Array.isArray(order[index + 1]) ? order[index + 1] : [], depth += 1;
  }
  return 0;
};
var sortStoriesCommon = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter) {
    let sortFn;
    typeof storySortParameter == "function" ? sortFn = storySortParameter : sortFn = storySort(storySortParameter), stories.sort(sortFn);
  } else
    stories.sort((s1, s2) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s2.importPath));
  return stories;
};
var toIndexEntry = (story) => {
  let { id, title, name, parameters, type } = story;
  return { id, title, name, importPath: parameters.fileName, type };
};
var sortStoriesV6 = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter && typeof storySortParameter == "function")
    return stories.sort(storySortParameter), stories.map((s) => toIndexEntry(s[1]));
  let storiesV7 = stories.map((s) => toIndexEntry(s[1]));
  return sortStoriesCommon(storiesV7, storySortParameter, fileNameOrder);
};

// node_modules/@storybook/preview-api/dist/chunk-7ZZCKEE2.mjs
var import_csf6 = __toESM(require_dist(), 1);
var import_synchronous_promise2 = __toESM(require_synchronous_promise(), 1);
var import_csf7 = __toESM(require_dist(), 1);
var import_qs = __toESM(require_lib(), 1);
var AUTODOCS_TAG = "autodocs";
var STORIES_MDX_TAG = "stories-mdx";
var StoryStoreFacade = class {
  constructor() {
    this.projectAnnotations = { loaders: [], decorators: [], parameters: {}, argsEnhancers: [], argTypesEnhancers: [], args: {}, argTypes: {} }, this.entries = {}, this.csfExports = {};
  }
  importFn(path) {
    return import_synchronous_promise2.SynchronousPromise.resolve().then(() => {
      let moduleExports = this.csfExports[path];
      if (!moduleExports)
        throw new Error(`Unknown path: ${path}`);
      return moduleExports;
    });
  }
  getStoryIndex(store) {
    var _a, _b;
    let fileNameOrder = Object.keys(this.csfExports), storySortParameter = (_b = (_a = this.projectAnnotations.parameters) == null ? void 0 : _a.options) == null ? void 0 : _b.storySort, sortableV6 = Object.entries(this.entries).map(([storyId, { type, importPath, ...entry }]) => {
      let exports = this.csfExports[importPath], csfFile = store.processCSFFileWithCache(exports, importPath, exports.default.title), storyLike;
      return type === "story" ? storyLike = store.storyFromCSFFile({ storyId, csfFile }) : storyLike = { ...entry, story: entry.name, kind: entry.title, componentId: (0, import_csf7.toId)(entry.componentId || entry.title), parameters: { fileName: importPath } }, [storyId, storyLike, csfFile.meta.parameters, this.projectAnnotations.parameters || {}];
    }), sortedV7;
    try {
      sortedV7 = sortStoriesV6(sortableV6, storySortParameter, fileNameOrder);
    } catch (err) {
      throw typeof storySortParameter == "function" ? new Error(dedent`
          Error sorting stories with sort parameter ${storySortParameter}:

          > ${err.message}
          
          Are you using a V7-style sort function in V6 compatibility mode?
          
          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
        `) : err;
    }
    return { v: 4, entries: sortedV7.reduce((acc, s) => (acc[s.id] = this.entries[s.id], acc), {}) };
  }
  clearFilenameExports(fileName) {
    this.csfExports[fileName] && (Object.entries(this.entries).forEach(([id, { importPath }]) => {
      importPath === fileName && delete this.entries[id];
    }), this.csfExports[fileName] = {});
  }
  addStoriesFromExports(fileName, fileExports) {
    if (fileName.match(/\.mdx$/) && !fileName.match(/\.stories\.mdx$/) || this.csfExports[fileName] === fileExports)
      return;
    this.clearFilenameExports(fileName);
    let { default: defaultExport, __namedExportsOrder, ...namedExports } = fileExports, { id: componentId, title, tags: componentTags = [] } = defaultExport || {}, specifiers = (scope.STORIES || []).map((specifier) => ({ ...specifier, importPathMatcher: new RegExp(specifier.importPathMatcher) }));
    if (title = userOrAutoTitle(fileName, specifiers, title), !title) {
      logger.info(`Unexpected default export without title in '${fileName}': ${JSON.stringify(fileExports.default)}`);
      return;
    }
    this.csfExports[fileName] = { ...fileExports, default: { ...defaultExport, title } };
    let sortedExports = namedExports;
    Array.isArray(__namedExportsOrder) && (sortedExports = {}, __namedExportsOrder.forEach((name) => {
      let namedExport = namedExports[name];
      namedExport && (sortedExports[name] = namedExport);
    }));
    let storyExports = Object.entries(sortedExports).filter(([key]) => (0, import_csf7.isExportStory)(key, defaultExport)), docsOptions = scope.DOCS_OPTIONS || {}, { autodocs } = docsOptions, componentAutodocs = componentTags.includes(AUTODOCS_TAG), autodocsOptedIn = autodocs === true || autodocs === "tag" && componentAutodocs;
    if (!docsOptions.disable && storyExports.length && (componentTags.includes(STORIES_MDX_TAG) || autodocsOptedIn)) {
      let name = docsOptions.defaultName, docsId = (0, import_csf7.toId)(componentId || title, name);
      this.entries[docsId] = { type: "docs", id: docsId, title, name, importPath: fileName, ...componentId && { componentId }, tags: [...componentTags, "docs", ...autodocsOptedIn && !componentAutodocs ? [AUTODOCS_TAG] : []], storiesImports: [] };
    }
    storyExports.forEach(([key, storyExport]) => {
      var _a, _b, _c;
      let exportName = (0, import_csf7.storyNameFromExport)(key), id = ((_a = storyExport.parameters) == null ? void 0 : _a.__id) || (0, import_csf7.toId)(componentId || title, exportName), name = typeof storyExport != "function" && storyExport.name || storyExport.storyName || ((_b = storyExport.story) == null ? void 0 : _b.name) || exportName;
      ((_c = storyExport.parameters) == null ? void 0 : _c.docsOnly) || (this.entries[id] = { type: "story", id, name, title, importPath: fileName, ...componentId && { componentId }, tags: [...storyExport.tags || componentTags, "story"] });
    });
  }
};
var invalidStoryTypes = /* @__PURE__ */ new Set(["string", "number", "boolean", "symbol"]);
var ClientApi = class {
  constructor({ storyStore } = {}) {
    this.lastFileName = 0;
    this.addDecorator = (decorator) => {
      var _a;
      (_a = this.facade.projectAnnotations.decorators) == null ? void 0 : _a.push(decorator);
    };
    this.addParameters = ({ globals, globalTypes, ...parameters }) => {
      this.facade.projectAnnotations.parameters = combineParameters(this.facade.projectAnnotations.parameters, parameters), globals && (this.facade.projectAnnotations.globals = { ...this.facade.projectAnnotations.globals, ...globals }), globalTypes && (this.facade.projectAnnotations.globalTypes = { ...this.facade.projectAnnotations.globalTypes, ...normalizeInputTypes(globalTypes) });
    };
    this.addStepRunner = (stepRunner) => {
      this.facade.projectAnnotations.runStep = composeStepRunners([this.facade.projectAnnotations.runStep, stepRunner].filter(Boolean));
    };
    this.addLoader = (loader) => {
      var _a;
      (_a = this.facade.projectAnnotations.loaders) == null ? void 0 : _a.push(loader);
    };
    this.addArgs = (args) => {
      this.facade.projectAnnotations.args = { ...this.facade.projectAnnotations.args, ...args };
    };
    this.addArgTypes = (argTypes) => {
      this.facade.projectAnnotations.argTypes = { ...this.facade.projectAnnotations.argTypes, ...normalizeInputTypes(argTypes) };
    };
    this.addArgsEnhancer = (enhancer) => {
      var _a;
      (_a = this.facade.projectAnnotations.argsEnhancers) == null ? void 0 : _a.push(enhancer);
    };
    this.addArgTypesEnhancer = (enhancer) => {
      var _a;
      (_a = this.facade.projectAnnotations.argTypesEnhancers) == null ? void 0 : _a.push(enhancer);
    };
    this._addedExports = {};
    this.storiesOf = (kind, m) => {
      if (!kind && typeof kind != "string")
        throw new Error("Invalid or missing kind provided for stories, should be a string");
      if (m || logger.warn(`Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`), m) {
        let proto = Object.getPrototypeOf(m);
        proto.exports && proto.exports.default && logger.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`);
      }
      let baseFilename = m && m.id ? `${m.id}` : (this.lastFileName++).toString(), fileName = baseFilename, i = 1;
      for (; this._addedExports[fileName]; )
        i += 1, fileName = `${baseFilename}-${i}`;
      m && m.hot && m.hot.accept && (m.hot.accept(), m.hot.dispose(() => {
        this.facade.clearFilenameExports(fileName), delete this._addedExports[fileName], setTimeout(() => {
          var _a;
          this._loadAddedExports(), (_a = this.onImportFnChanged) == null ? void 0 : _a.call(this, { importFn: this.importFn.bind(this) });
        }, 0);
      }));
      let hasAdded = false, api = { kind: kind.toString(), add: () => api, addDecorator: () => api, addLoader: () => api, addParameters: () => api };
      Object.keys(this.addons).forEach((name) => {
        let addon = this.addons[name];
        api[name] = (...args) => (addon.apply(api, args), api);
      });
      let meta = { id: (0, import_csf6.sanitize)(kind), title: kind, decorators: [], loaders: [], parameters: {} };
      this._addedExports[fileName] = { default: meta };
      let counter = 0;
      return api.add = (storyName, storyFn, parameters = {}) => {
        if (hasAdded = true, typeof storyName != "string")
          throw new Error(`Invalid or missing storyName provided for a "${kind}" story.`);
        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn))
          throw new Error(`Cannot load story "${storyName}" in "${kind}" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`);
        let { decorators, loaders, component, args, argTypes, ...storyParameters } = parameters, storyId = parameters.__id || (0, import_csf6.toId)(kind, storyName), csfExports = this._addedExports[fileName];
        return csfExports[`story${counter}`] = { name: storyName, parameters: { fileName, __id: storyId, ...storyParameters }, decorators, loaders, args, argTypes, component, render: storyFn }, counter += 1, api;
      }, api.addDecorator = (decorator) => {
        var _a;
        if (hasAdded)
          throw new Error(`You cannot add a decorator after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        return (_a = meta.decorators) == null ? void 0 : _a.push(decorator), api;
      }, api.addLoader = (loader) => {
        var _a;
        if (hasAdded)
          throw new Error("You cannot add a loader after the first story for a kind.");
        return (_a = meta.loaders) == null ? void 0 : _a.push(loader), api;
      }, api.addParameters = ({ component, args, argTypes, tags, ...parameters }) => {
        if (hasAdded)
          throw new Error(`You cannot add parameters after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        return meta.parameters = combineParameters(meta.parameters, parameters), component && (meta.component = component), args && (meta.args = { ...meta.args, ...args }), argTypes && (meta.argTypes = { ...meta.argTypes, ...argTypes }), tags && (meta.tags = tags), api;
      }, api;
    };
    this.raw = () => {
      var _a;
      return (_a = this.storyStore) == null ? void 0 : _a.raw();
    };
    this.facade = new StoryStoreFacade(), this.addons = {}, this.storyStore = storyStore;
  }
  importFn(path) {
    return this.facade.importFn(path);
  }
  getStoryIndex() {
    if (!this.storyStore)
      throw new Error("Cannot get story index before setting storyStore");
    return this.facade.getStoryIndex(this.storyStore);
  }
  _loadAddedExports() {
    Object.entries(this._addedExports).forEach(([fileName, fileExports]) => this.facade.addStoriesFromExports(fileName, fileExports));
  }
  get _storyStore() {
    return this.storyStore;
  }
};

// node_modules/@storybook/preview-api/dist/chunk-SJSTZ43Q.mjs
var import_synchronous_promise3 = __toESM(require_synchronous_promise(), 1);
var import_qs2 = __toESM(require_lib(), 1);
var import_qs3 = __toESM(require_lib(), 1);
var import_isPlainObject3 = __toESM(require_isPlainObject(), 1);
var import_qs4 = __toESM(require_lib(), 1);
var require_entities = __commonJS({ "../../node_modules/entities/lib/maps/entities.json"(exports, module) {
  module.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: `
`, nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "	", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "‍", zwnj: "‌" };
} });
var require_legacy = __commonJS({ "../../node_modules/entities/lib/maps/legacy.json"(exports, module) {
  module.exports = { Aacute: "Á", aacute: "á", Acirc: "Â", acirc: "â", acute: "´", AElig: "Æ", aelig: "æ", Agrave: "À", agrave: "à", amp: "&", AMP: "&", Aring: "Å", aring: "å", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", brvbar: "¦", Ccedil: "Ç", ccedil: "ç", cedil: "¸", cent: "¢", copy: "©", COPY: "©", curren: "¤", deg: "°", divide: "÷", Eacute: "É", eacute: "é", Ecirc: "Ê", ecirc: "ê", Egrave: "È", egrave: "è", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", frac12: "½", frac14: "¼", frac34: "¾", gt: ">", GT: ">", Iacute: "Í", iacute: "í", Icirc: "Î", icirc: "î", iexcl: "¡", Igrave: "Ì", igrave: "ì", iquest: "¿", Iuml: "Ï", iuml: "ï", laquo: "«", lt: "<", LT: "<", macr: "¯", micro: "µ", middot: "·", nbsp: " ", not: "¬", Ntilde: "Ñ", ntilde: "ñ", Oacute: "Ó", oacute: "ó", Ocirc: "Ô", ocirc: "ô", Ograve: "Ò", ograve: "ò", ordf: "ª", ordm: "º", Oslash: "Ø", oslash: "ø", Otilde: "Õ", otilde: "õ", Ouml: "Ö", ouml: "ö", para: "¶", plusmn: "±", pound: "£", quot: '"', QUOT: '"', raquo: "»", reg: "®", REG: "®", sect: "§", shy: "­", sup1: "¹", sup2: "²", sup3: "³", szlig: "ß", THORN: "Þ", thorn: "þ", times: "×", Uacute: "Ú", uacute: "ú", Ucirc: "Û", ucirc: "û", Ugrave: "Ù", ugrave: "ù", uml: "¨", Uuml: "Ü", uuml: "ü", Yacute: "Ý", yacute: "ý", yen: "¥", yuml: "ÿ" };
} });
var require_xml = __commonJS({ "../../node_modules/entities/lib/maps/xml.json"(exports, module) {
  module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
} });
var require_decode = __commonJS({ "../../node_modules/entities/lib/maps/decode.json"(exports, module) {
  module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
} });
var require_decode_codepoint = __commonJS({ "../../node_modules/entities/lib/decode_codepoint.js"(exports) {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var decode_json_1 = __importDefault(require_decode()), fromCodePoint = String.fromCodePoint || function(codePoint) {
    var output = "";
    return codePoint > 65535 && (codePoint -= 65536, output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), output += String.fromCharCode(codePoint), output;
  };
  function decodeCodePoint(codePoint) {
    return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? "�" : (codePoint in decode_json_1.default && (codePoint = decode_json_1.default[codePoint]), fromCodePoint(codePoint));
  }
  exports.default = decodeCodePoint;
} });
var require_decode2 = __commonJS({ "../../node_modules/entities/lib/decode.js"(exports) {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
  var entities_json_1 = __importDefault(require_entities()), legacy_json_1 = __importDefault(require_legacy()), xml_json_1 = __importDefault(require_xml()), decode_codepoint_1 = __importDefault(require_decode_codepoint()), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  exports.decodeXML = getStrictDecoder(xml_json_1.default);
  exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
  function getStrictDecoder(map2) {
    var replace = getReplacer(map2);
    return function(str) {
      return String(str).replace(strictEntityRe, replace);
    };
  }
  var sorter = function(a, b) {
    return a < b ? 1 : -1;
  };
  exports.decodeHTML = function() {
    for (var legacy = Object.keys(legacy_json_1.default).sort(sorter), keys = Object.keys(entities_json_1.default).sort(sorter), i = 0, j = 0; i < keys.length; i++)
      legacy[j] === keys[i] ? (keys[i] += ";?", j++) : keys[i] += ";";
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entities_json_1.default);
    function replacer(str) {
      return str.substr(-1) !== ";" && (str += ";"), replace(str);
    }
    return function(str) {
      return String(str).replace(re, replacer);
    };
  }();
  function getReplacer(map2) {
    return function(str) {
      if (str.charAt(1) === "#") {
        var secondChar = str.charAt(2);
        return secondChar === "X" || secondChar === "x" ? decode_codepoint_1.default(parseInt(str.substr(3), 16)) : decode_codepoint_1.default(parseInt(str.substr(2), 10));
      }
      return map2[str.slice(1, -1)] || str;
    };
  }
} });
var require_encode = __commonJS({ "../../node_modules/entities/lib/encode.js"(exports) {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
  var xml_json_1 = __importDefault(require_xml()), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
  exports.encodeXML = getASCIIEncoder(inverseXML);
  var entities_json_1 = __importDefault(require_entities()), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
  exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
  function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function(inverse, name) {
      return inverse[obj[name]] = "&" + name + ";", inverse;
    }, {});
  }
  function getInverseReplacer(inverse) {
    for (var single = [], multiple = [], _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
      var k = _a[_i];
      k.length === 1 ? single.push("\\" + k) : multiple.push(k);
    }
    single.sort();
    for (var start2 = 0; start2 < single.length - 1; start2++) {
      for (var end = start2; end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1); )
        end += 1;
      var count = 1 + end - start2;
      count < 3 || single.splice(start2, count, single[start2] + "-" + single[end]);
    }
    return multiple.unshift("[" + single.join("") + "]"), new RegExp(multiple.join("|"), "g");
  }
  var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = String.prototype.codePointAt != null ? function(str) {
    return str.codePointAt(0);
  } : function(c) {
    return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
  };
  function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  function getInverse(inverse, re) {
    return function(data) {
      return data.replace(re, function(name) {
        return inverse[name];
      }).replace(reNonASCII, singleCharReplacer);
    };
  }
  var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
  function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
  }
  exports.escape = escape;
  function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
  }
  exports.escapeUTF8 = escapeUTF8;
  function getASCIIEncoder(obj) {
    return function(data) {
      return data.replace(reEscapeChars, function(c) {
        return obj[c] || singleCharReplacer(c);
      });
    };
  }
} });
var require_lib2 = __commonJS({ "../../node_modules/entities/lib/index.js"(exports) {
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
  var decode_1 = require_decode2(), encode_1 = require_encode();
  function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
  }
  exports.decode = decode;
  function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
  }
  exports.decodeStrict = decodeStrict;
  function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
  }
  exports.encode = encode;
  var encode_2 = require_encode();
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return encode_2.encodeXML;
  } });
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return encode_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return encode_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  var decode_2 = require_decode2();
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
} });
var require_ansi_to_html = __commonJS({ "../../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module) {
  "use strict";
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
  }
  function _createForOfIteratorHelper(o) {
    if (typeof Symbol > "u" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
        var i = 0, F = function() {
        };
        return { s: F, n: function() {
          return i >= o.length ? { done: true } : { done: false, value: o[i++] };
        }, e: function(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var it, normalCompletion = true, didErr = false, err;
    return { s: function() {
      it = o[Symbol.iterator]();
    }, n: function() {
      var step = it.next();
      return normalCompletion = step.done, step;
    }, e: function(_e2) {
      didErr = true, err = _e2;
    }, f: function() {
      try {
        !normalCompletion && it.return != null && it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (o) {
      if (typeof o == "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
  }
  function _arrayLikeToArray(arr, len) {
    (len == null || len > arr.length) && (len = arr.length);
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  var entities = require_lib2(), defaults = { fg: "#FFF", bg: "#000", newline: false, escapeXML: false, stream: false, colors: getDefaultColors() };
  function getDefaultColors() {
    var colors = { 0: "#000", 1: "#A00", 2: "#0A0", 3: "#A50", 4: "#00A", 5: "#A0A", 6: "#0AA", 7: "#AAA", 8: "#555", 9: "#F55", 10: "#5F5", 11: "#FF5", 12: "#55F", 13: "#F5F", 14: "#5FF", 15: "#FFF" };
    return range(0, 5).forEach(function(red) {
      range(0, 5).forEach(function(green) {
        range(0, 5).forEach(function(blue) {
          return setStyleColor(red, green, blue, colors);
        });
      });
    }), range(0, 23).forEach(function(gray) {
      var c = gray + 232, l = toHexString(gray * 10 + 8);
      colors[c] = "#" + l + l + l;
    }), colors;
  }
  function setStyleColor(red, green, blue, colors) {
    var c = 16 + red * 36 + green * 6 + blue, r = red > 0 ? red * 40 + 55 : 0, g = green > 0 ? green * 40 + 55 : 0, b = blue > 0 ? blue * 40 + 55 : 0;
    colors[c] = toColorHexString([r, g, b]);
  }
  function toHexString(num) {
    for (var str = num.toString(16); str.length < 2; )
      str = "0" + str;
    return str;
  }
  function toColorHexString(ref) {
    var results = [], _iterator = _createForOfIteratorHelper(ref), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var r = _step.value;
        results.push(toHexString(r));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return "#" + results.join("");
  }
  function generateOutput(stack, token, data, options) {
    var result;
    return token === "text" ? result = pushText(data, options) : token === "display" ? result = handleDisplay(stack, data, options) : token === "xterm256" ? result = pushForegroundColor(stack, options.colors[data]) : token === "rgb" && (result = handleRgb(stack, data)), result;
  }
  function handleRgb(stack, data) {
    data = data.substring(2).slice(0, -1);
    var operation = +data.substr(0, 2), color = data.substring(5).split(";"), rgb = color.map(function(value) {
      return ("0" + Number(value).toString(16)).substr(-2);
    }).join("");
    return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb);
  }
  function handleDisplay(stack, code, options) {
    code = parseInt(code, 10);
    var codeMap = { "-1": function() {
      return "<br/>";
    }, 0: function() {
      return stack.length && resetStyles(stack);
    }, 1: function() {
      return pushTag(stack, "b");
    }, 3: function() {
      return pushTag(stack, "i");
    }, 4: function() {
      return pushTag(stack, "u");
    }, 8: function() {
      return pushStyle(stack, "display:none");
    }, 9: function() {
      return pushTag(stack, "strike");
    }, 22: function() {
      return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
    }, 23: function() {
      return closeTag(stack, "i");
    }, 24: function() {
      return closeTag(stack, "u");
    }, 39: function() {
      return pushForegroundColor(stack, options.fg);
    }, 49: function() {
      return pushBackgroundColor(stack, options.bg);
    }, 53: function() {
      return pushStyle(stack, "text-decoration:overline");
    } }, result;
    return codeMap[code] ? result = codeMap[code]() : 4 < code && code < 7 ? result = pushTag(stack, "blink") : 29 < code && code < 38 ? result = pushForegroundColor(stack, options.colors[code - 30]) : 39 < code && code < 48 ? result = pushBackgroundColor(stack, options.colors[code - 40]) : 89 < code && code < 98 ? result = pushForegroundColor(stack, options.colors[8 + (code - 90)]) : 99 < code && code < 108 && (result = pushBackgroundColor(stack, options.colors[8 + (code - 100)])), result;
  }
  function resetStyles(stack) {
    var stackClone = stack.slice(0);
    return stack.length = 0, stackClone.reverse().map(function(tag) {
      return "</" + tag + ">";
    }).join("");
  }
  function range(low, high) {
    for (var results = [], j = low; j <= high; j++)
      results.push(j);
    return results;
  }
  function notCategory(category) {
    return function(e) {
      return (category === null || e.category !== category) && category !== "all";
    };
  }
  function categoryForCode(code) {
    code = parseInt(code, 10);
    var result = null;
    return code === 0 ? result = "all" : code === 1 ? result = "bold" : 2 < code && code < 5 ? result = "underline" : 4 < code && code < 7 ? result = "blink" : code === 8 ? result = "hide" : code === 9 ? result = "strike" : 29 < code && code < 38 || code === 39 || 89 < code && code < 98 ? result = "foreground-color" : (39 < code && code < 48 || code === 49 || 99 < code && code < 108) && (result = "background-color"), result;
  }
  function pushText(text, options) {
    return options.escapeXML ? entities.encodeXML(text) : text;
  }
  function pushTag(stack, tag, style) {
    return style || (style = ""), stack.push(tag), "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
  }
  function pushStyle(stack, style) {
    return pushTag(stack, "span", style);
  }
  function pushForegroundColor(stack, color) {
    return pushTag(stack, "span", "color:" + color);
  }
  function pushBackgroundColor(stack, color) {
    return pushTag(stack, "span", "background-color:" + color);
  }
  function closeTag(stack, style) {
    var last;
    if (stack.slice(-1)[0] === style && (last = stack.pop()), last)
      return "</" + style + ">";
  }
  function tokenize(text, options, callback) {
    var ansiMatch = false, ansiHandler = 3;
    function remove() {
      return "";
    }
    function removeXterm256(m, g1) {
      return callback("xterm256", g1), "";
    }
    function newline(m) {
      return options.newline ? callback("display", -1) : callback("text", m), "";
    }
    function ansiMess(m, g1) {
      ansiMatch = true, g1.trim().length === 0 && (g1 = "0"), g1 = g1.trimRight(";").split(";");
      var _iterator2 = _createForOfIteratorHelper(g1), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var g = _step2.value;
          callback("display", g);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return "";
    }
    function realText(m) {
      return callback("text", m), "";
    }
    function rgb(m) {
      return callback("rgb", m), "";
    }
    var tokens = [{ pattern: /^\x08+/, sub: remove }, { pattern: /^\x1b\[[012]?K/, sub: remove }, { pattern: /^\x1b\[\(B/, sub: remove }, { pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/, sub: rgb }, { pattern: /^\x1b\[38;5;(\d+)m/, sub: removeXterm256 }, { pattern: /^\n/, sub: newline }, { pattern: /^\r+\n/, sub: newline }, { pattern: /^\x1b\[((?:\d{1,3};?)+|)m/, sub: ansiMess }, { pattern: /^\x1b\[\d?J/, sub: remove }, { pattern: /^\x1b\[\d{0,3};\d{0,3}f/, sub: remove }, { pattern: /^\x1b\[?[\d;]{0,3}/, sub: remove }, { pattern: /^(([^\x1b\x08\r\n])+)/, sub: realText }];
    function process(handler2, i2) {
      i2 > ansiHandler && ansiMatch || (ansiMatch = false, text = text.replace(handler2.pattern, handler2.sub));
    }
    var results1 = [], _text = text, length = _text.length;
    outer:
      for (; length > 0; ) {
        for (var i = 0, o = 0, len = tokens.length; o < len; i = ++o) {
          var handler = tokens[i];
          if (process(handler, i), text.length !== length) {
            length = text.length;
            continue outer;
          }
        }
        if (text.length === length)
          break;
        results1.push(0), length = text.length;
      }
    return results1;
  }
  function updateStickyStack(stickyStack, token, data) {
    return token !== "text" && (stickyStack = stickyStack.filter(notCategory(categoryForCode(data))), stickyStack.push({ token, data, category: categoryForCode(data) })), stickyStack;
  }
  var Filter = function() {
    function Filter2(options) {
      _classCallCheck(this, Filter2), options = options || {}, options.colors && (options.colors = Object.assign({}, defaults.colors, options.colors)), this.options = Object.assign({}, defaults, options), this.stack = [], this.stickyStack = [];
    }
    return _createClass(Filter2, [{ key: "toHtml", value: function(input) {
      var _this = this;
      input = typeof input == "string" ? [input] : input;
      var stack = this.stack, options = this.options, buf = [];
      return this.stickyStack.forEach(function(element) {
        var output = generateOutput(stack, element.token, element.data, options);
        output && buf.push(output);
      }), tokenize(input.join(""), options, function(token, data) {
        var output = generateOutput(stack, token, data, options);
        output && buf.push(output), options.stream && (_this.stickyStack = updateStickyStack(_this.stickyStack, token, data));
      }), stack.length && buf.push(resetStyles(stack)), buf.join("");
    } }]), Filter2;
  }();
  module.exports = Filter;
} });
var PREPARE_ABORTED = new Error("prepareAborted");
var { AbortController } = globalThis;
function serializeError(error) {
  try {
    let { name = "Error", message = String(error), stack } = error;
    return { name, message, stack };
  } catch {
    return { name: "Error", message: String(error) };
  }
}
var StoryRender = class {
  constructor(channel, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: true, forceInitialArgs: false }, story) {
    this.channel = channel;
    this.store = store;
    this.renderToScreen = renderToScreen;
    this.callbacks = callbacks;
    this.id = id;
    this.viewMode = viewMode;
    this.renderOptions = renderOptions;
    this.type = "story";
    this.notYetRendered = true;
    this.disableKeyListeners = false;
    this.teardownRender = () => {
    };
    this.torndown = false;
    this.abortController = new AbortController(), story && (this.story = story, this.phase = "preparing");
  }
  async runPhase(signal, phase, phaseFn) {
    this.phase = phase, this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: this.phase, storyId: this.id }), phaseFn && await phaseFn(), signal.aborted && (this.phase = "aborted", this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: this.phase, storyId: this.id }));
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw this.store.cleanupStory(this.story), PREPARE_ABORTED;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["rendering", "playing"].includes(this.phase);
  }
  async renderToElement(canvasElement) {
    return this.canvasElement = canvasElement, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    return this.store.getStoryContext(this.story);
  }
  async render({ initial = false, forceRemount = false } = {}) {
    let { canvasElement } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    if (!canvasElement)
      throw new Error("cannot render when canvasElement is unset");
    let { id, componentId, title, name, tags, applyLoaders, unboundStoryFn, playFunction, prepareContext, initialArgs } = this.story;
    forceRemount && !initial && (this.cancelRender(), this.abortController = new AbortController());
    let abortSignal = this.abortController.signal;
    try {
      let getCurrentContext = () => prepareContext({ ...this.storyContext(), ...this.renderOptions.forceInitialArgs && { args: initialArgs } }), loadedContext;
      if (await this.runPhase(abortSignal, "loading", async () => {
        loadedContext = await applyLoaders({ ...getCurrentContext(), viewMode: this.viewMode });
      }), abortSignal.aborted)
        return;
      let renderStoryContext = { ...loadedContext, ...getCurrentContext(), abortSignal, canvasElement }, renderContext = { componentId, title, kind: title, id, name, story: name, tags, ...this.callbacks, showError: (error) => (this.phase = "errored", this.callbacks.showError(error)), showException: (error) => (this.phase = "errored", this.callbacks.showException(error)), forceRemount: forceRemount || this.notYetRendered, storyContext: renderStoryContext, storyFn: () => unboundStoryFn(renderStoryContext), unboundStoryFn };
      if (await this.runPhase(abortSignal, "rendering", async () => {
        let teardown = await this.renderToScreen(renderContext, canvasElement);
        this.teardownRender = teardown || (() => {
        });
      }), this.notYetRendered = false, abortSignal.aborted)
        return;
      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
        this.disableKeyListeners = true;
        try {
          await this.runPhase(abortSignal, "playing", async () => {
            await playFunction(renderContext.storyContext);
          }), await this.runPhase(abortSignal, "played");
        } catch (error) {
          if (logger.error(error), await this.runPhase(abortSignal, "errored", async () => {
            this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw error;
        }
        if (this.disableKeyListeners = false, abortSignal.aborted)
          return;
      }
      await this.runPhase(abortSignal, "completed", async () => this.channel.emit(STORY_RENDERED, id));
    } catch (err) {
      this.phase = "errored", this.callbacks.showException(err);
    }
  }
  async rerender() {
    return this.render();
  }
  async remount() {
    return this.render({ forceRemount: true });
  }
  cancelRender() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && this.store.cleanupStory(this.story);
    for (let i = 0; i < 3; i += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    window.location.reload(), await new Promise(() => {
    });
  }
};
var { fetch } = scope;
var STORY_INDEX_PATH = "./index.json";
var Preview = class {
  constructor(channel = addons.getChannel()) {
    var _a;
    this.channel = channel;
    this.storyRenders = [];
    ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) && addons.hasServerChannel() && (this.serverChannel = addons.getServerChannel()), this.storyStore = new StoryStore();
  }
  initialize({ getStoryIndex, importFn, getProjectAnnotations }) {
    return this.getStoryIndex = getStoryIndex, this.importFn = importFn, this.setupListeners(), this.getProjectAnnotationsOrRenderError(getProjectAnnotations).then((projectAnnotations) => this.initializeWithProjectAnnotations(projectAnnotations));
  }
  setupListeners() {
    var _a;
    (_a = this.serverChannel) == null ? void 0 : _a.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this)), this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this)), this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this)), this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this)), this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this)), this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this));
  }
  getProjectAnnotationsOrRenderError(getProjectAnnotations) {
    return import_synchronous_promise3.SynchronousPromise.resolve().then(getProjectAnnotations).then((projectAnnotations) => {
      if (projectAnnotations.renderToDOM && deprecate("`renderToDOM` is deprecated, please rename to `renderToCanvas`"), this.renderToCanvas = projectAnnotations.renderToCanvas || projectAnnotations.renderToDOM, !this.renderToCanvas)
        throw new Error(dedent`
            Expected your framework's preset to export a \`renderToCanvas\` field.

            Perhaps it needs to be upgraded for Storybook 6.4?

            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field
          `);
      return projectAnnotations;
    }).catch((err) => {
      throw this.renderPreviewEntryError("Error reading preview.js:", err), err;
    });
  }
  initializeWithProjectAnnotations(projectAnnotations) {
    var _a;
    this.storyStore.setProjectAnnotations(projectAnnotations), this.setInitialGlobals();
    let storyIndexPromise;
    if ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7)
      storyIndexPromise = this.getStoryIndexFromServer();
    else {
      if (!this.getStoryIndex)
        throw new Error("No `getStoryIndex` passed defined in v6 mode");
      storyIndexPromise = import_synchronous_promise3.SynchronousPromise.resolve().then(this.getStoryIndex);
    }
    return storyIndexPromise.then((storyIndex) => this.initializeWithStoryIndex(storyIndex)).catch((err) => {
      throw this.renderPreviewEntryError("Error loading story index:", err), err;
    });
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStore.globals || !this.storyStore.projectAnnotations)
      throw new Error("Cannot emit before initialization");
    let payload = { globals: this.storyStore.globals.get() || {}, globalTypes: this.storyStore.projectAnnotations.globalTypes || {} };
    this.channel.emit(SET_GLOBALS, payload);
  }
  async getStoryIndexFromServer() {
    let result = await fetch(STORY_INDEX_PATH);
    if (result.status === 200)
      return result.json();
    throw new Error(await result.text());
  }
  initializeWithStoryIndex(storyIndex) {
    var _a;
    if (!this.importFn)
      throw new Error("Cannot call initializeWithStoryIndex before initialization");
    return this.storyStore.initialize({ storyIndex, importFn: this.importFn, cache: !((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) });
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations }) {
    delete this.previewEntryError;
    let projectAnnotations = await this.getProjectAnnotationsOrRenderError(getProjectAnnotations);
    if (!this.storyStore.projectAnnotations) {
      await this.initializeWithProjectAnnotations(projectAnnotations);
      return;
    }
    await this.storyStore.setProjectAnnotations(projectAnnotations), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !!this.storyStore.projectAnnotations)
      try {
        let storyIndex = await this.getStoryIndexFromServer();
        this.storyStore.storyIndex || await this.initializeWithStoryIndex(storyIndex), await this.onStoriesChanged({ storyIndex });
      } catch (err) {
        throw this.renderPreviewEntryError("Error loading story index:", err), err;
      }
  }
  async onStoriesChanged({ importFn, storyIndex }) {
    await this.storyStore.onStoriesChanged({ importFn, storyIndex });
  }
  async onUpdateGlobals({ globals }) {
    if (!this.storyStore.globals)
      throw new Error("Cannot call onUpdateGlobals before initialization");
    this.storyStore.globals.update(globals), await Promise.all(this.storyRenders.map((r) => r.rerender())), this.channel.emit(GLOBALS_UPDATED, { globals: this.storyStore.globals.get(), initialGlobals: this.storyStore.globals.initialGlobals });
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    this.storyStore.args.update(storyId, updatedArgs), await Promise.all(this.storyRenders.filter((r) => r.id === storyId && !r.renderOptions.forceInitialArgs).map((r) => r.rerender())), this.channel.emit(STORY_ARGS_UPDATED, { storyId, args: this.storyStore.args.get(storyId) });
  }
  async onResetArgs({ storyId, argNames }) {
    var _a;
    let story = ((_a = this.storyRenders.find((r) => r.id === storyId)) == null ? void 0 : _a.story) || await this.storyStore.loadStory({ storyId }), updatedArgs = (argNames || [.../* @__PURE__ */ new Set([...Object.keys(story.initialArgs), ...Object.keys(this.storyStore.args.get(storyId))])]).reduce((acc, argName) => (acc[argName] = story.initialArgs[argName], acc), {});
    await this.onUpdateArgs({ storyId, updatedArgs });
  }
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((r) => r.rerender()));
  }
  async onForceRemount({ storyId }) {
    await Promise.all(this.storyRenders.filter((r) => r.id === storyId).map((r) => r.remount()));
  }
  renderStoryToElement(story, element, options) {
    if (!this.renderToCanvas)
      throw new Error("Cannot call renderStoryToElement before initialization");
    let render = new StoryRender(this.channel, this.storyStore, this.renderToCanvas, this.inlineStoryCallbacks(story.id), story.id, "docs", options, story);
    return render.renderToElement(element), this.storyRenders.push(render), async () => {
      await this.teardownRender(render);
    };
  }
  async teardownRender(render, { viewModeChanged } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((r) => r !== render), await ((_a = render == null ? void 0 : render.teardown) == null ? void 0 : _a.call(render, { viewModeChanged }));
  }
  async extract(options) {
    var _a;
    if (this.previewEntryError)
      throw this.previewEntryError;
    if (!this.storyStore.projectAnnotations)
      throw new Error(dedent`Failed to initialize Storybook.

      Do you have an error in your \`preview.js\`? Check your Storybook's browser console for errors.`);
    return ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) && await this.storyStore.cacheAllCSFFiles(), this.storyStore.extract(options);
  }
  inlineStoryCallbacks(storyId) {
    return { showMain: () => {
    }, showError: (err) => logger.error(`Error rendering docs story (${storyId})`, err), showException: (err) => logger.error(`Error rendering docs story (${storyId})`, err) };
  }
  renderPreviewEntryError(reason, err) {
    this.previewEntryError = err, logger.error(reason), logger.error(err), this.channel.emit(CONFIG_ERROR, err);
  }
};
var DocsContext = class {
  constructor(channel, store, renderStoryToElement, csfFiles) {
    this.channel = channel;
    this.store = store;
    this.renderStoryToElement = renderStoryToElement;
    this.storyIdByName = (storyName) => {
      let storyId = this.nameToStoryId.get(storyName);
      if (storyId)
        return storyId;
      throw new Error(`No story found with that name: ${storyName}`);
    };
    this.componentStories = () => this.componentStoriesValue;
    this.storyById = (storyId) => {
      if (!storyId) {
        if (!this.primaryStory)
          throw new Error("No primary story defined for docs entry. Did you forget to use `<Meta>`?");
        return this.primaryStory;
      }
      let csfFile = this.storyIdToCSFFile.get(storyId);
      if (!csfFile)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
      return this.store.storyFromCSFFile({ storyId, csfFile });
    };
    this.getStoryContext = (story) => ({ ...this.store.getStoryContext(story), viewMode: "docs" });
    this.loadStory = (id) => this.store.loadStory({ storyId: id });
    this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.componentStoriesValue = [], csfFiles.forEach((csfFile, index) => {
      this.referenceCSFFile(csfFile);
    });
  }
  referenceCSFFile(csfFile) {
    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile), this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      let annotation = csfFile.stories[story.id];
      this.storyIdToCSFFile.set(annotation.id, csfFile), this.exportToStory.set(annotation.moduleExport, story);
    });
  }
  attachCSFFile(csfFile) {
    if (!this.exportsToCSFFile.has(csfFile.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    this.attachedCSFFile = csfFile, this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      this.nameToStoryId.set(story.name, story.id), this.componentStoriesValue.push(story), this.primaryStory || (this.primaryStory = story);
    });
  }
  referenceMeta(metaExports, attach) {
    let resolved = this.resolveModuleExport(metaExports);
    if (resolved.type !== "meta")
      throw new Error("Cannot reference a non-meta or module export in <Meta of={} />");
    attach && this.attachCSFFile(resolved.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations } = this.store;
    if (!projectAnnotations)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return projectAnnotations;
  }
  resolveAttachedModuleExportType(moduleExportType) {
    if (moduleExportType === "story") {
      if (!this.primaryStory)
        throw new Error("No primary story attached to this docs file, did you forget to use <Meta of={} />?");
      return { type: "story", story: this.primaryStory };
    }
    if (!this.attachedCSFFile)
      throw new Error("No CSF file attached to this docs file, did you forget to use <Meta of={} />?");
    if (moduleExportType === "meta")
      return { type: "meta", csfFile: this.attachedCSFFile };
    let { component } = this.attachedCSFFile.meta;
    if (!component)
      throw new Error("Attached CSF file does not defined a component, did you forget to export one?");
    return { type: "component", component };
  }
  resolveModuleExport(moduleExportOrType) {
    let csfFile = this.exportsToCSFFile.get(moduleExportOrType);
    if (csfFile)
      return { type: "meta", csfFile };
    let story = this.exportToStory.get(moduleExportOrType);
    return story ? { type: "story", story } : { type: "component", component: moduleExportOrType };
  }
  resolveOf(moduleExportOrType, validTypes = []) {
    let resolved;
    if (["component", "meta", "story"].includes(moduleExportOrType)) {
      let type = moduleExportOrType;
      resolved = this.resolveAttachedModuleExportType(type);
    } else
      resolved = this.resolveModuleExport(moduleExportOrType);
    if (validTypes.length && !validTypes.includes(resolved.type)) {
      let prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
      throw new Error(`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(", ")}`);
    }
    return resolved;
  }
};
var CsfDocsRender = class {
  constructor(channel, store, entry) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.type = "docs";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    let { importPath, title } = this.entry, primaryCsfFile = this.store.processCSFFileWithCache(entryExports, importPath, title), primaryStoryId = Object.keys(primaryCsfFile.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile }), this.csfFiles = [primaryCsfFile, ...csfFiles], this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = new DocsContext(this.channel, this.store, renderStoryToElement, this.csfFiles);
    return this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile)), docsContext;
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs: docsParameter } = this.story.parameters || {};
    if (!docsParameter)
      throw new Error("Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed");
    let renderer = await docsParameter.renderer(), { render } = renderer, renderDocs = async () => {
      await new Promise((r) => render(docsContext, docsParameter, canvasElement, r)), this.channel.emit(DOCS_RENDERED, this.id);
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged }) => {
      !viewModeChanged || !canvasElement || renderer.unmount(canvasElement);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged }), this.torndown = true;
  }
};
var MdxDocsRender = class {
  constructor(channel, store, entry) {
    this.channel = channel;
    this.store = store;
    this.entry = entry;
    this.type = "docs";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    this.csfFiles = csfFiles, this.exports = entryExports, this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.exports && this.exports === other.exports);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new DocsContext(this.channel, this.store, renderStoryToElement, this.csfFiles);
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs } = this.store.projectAnnotations.parameters || {};
    if (!docs)
      throw new Error("Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed");
    let docsParameter = { ...docs, page: this.exports.default }, renderer = await docs.renderer(), { render } = renderer, renderDocs = async () => {
      await new Promise((r) => render(docsContext, docsParameter, canvasElement, r)), this.channel.emit(DOCS_RENDERED, this.id);
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged } = {}) => {
      !viewModeChanged || !canvasElement || (renderer.unmount(canvasElement), this.torndown = true);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    var _a;
    (_a = this.teardownRender) == null ? void 0 : _a.call(this, { viewModeChanged }), this.torndown = true;
  }
};
var globalWindow = globalThis;
function focusInInput(event) {
  let target = event.target;
  return /input|textarea/i.test(target.tagName) || target.getAttribute("contenteditable") !== null;
}
var AUTODOCS_TAG2 = "autodocs";
var STORIES_MDX_TAG2 = "stories-mdx";
function isMdxEntry({ tags }) {
  return !(tags == null ? void 0 : tags.includes(AUTODOCS_TAG2)) && !(tags == null ? void 0 : tags.includes(STORIES_MDX_TAG2));
}
function isStoryRender(r) {
  return r.type === "story";
}
var PreviewWithSelection = class extends Preview {
  constructor(selectionStore, view) {
    super();
    this.selectionStore = selectionStore;
    this.view = view;
  }
  setupListeners() {
    super.setupListeners(), globalWindow.onkeydown = this.onKeydown.bind(this), this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this)), this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this)), this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));
  }
  initializeWithProjectAnnotations(projectAnnotations) {
    return super.initializeWithProjectAnnotations(projectAnnotations).then(() => this.setInitialGlobals());
  }
  async setInitialGlobals() {
    if (!this.storyStore.globals)
      throw new Error("Cannot call setInitialGlobals before initialization");
    let { globals } = this.selectionStore.selectionSpecifier || {};
    globals && this.storyStore.globals.updateFromPersisted(globals), this.emitGlobals();
  }
  initializeWithStoryIndex(storyIndex) {
    return super.initializeWithStoryIndex(storyIndex).then(() => {
      var _a;
      return ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) || this.channel.emit(SET_INDEX, this.storyStore.getSetIndexPayload()), this.selectSpecifiedStory();
    });
  }
  async selectSpecifiedStory() {
    if (!this.storyStore.storyIndex)
      throw new Error("Cannot call selectSpecifiedStory before initialization");
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier, args } = this.selectionStore.selectionSpecifier, entry = this.storyStore.storyIndex.entryFromSpecifier(storySpecifier);
    if (!entry) {
      storySpecifier === "*" ? this.renderStoryLoadingException(storySpecifier, new Error(dedent`
            Couldn't find any stories in your Storybook.
            - Please check your stories field of your main.js config.
            - Also check the browser console and terminal for error messages.
          `)) : this.renderStoryLoadingException(storySpecifier, new Error(dedent`
            Couldn't find story matching '${storySpecifier}'.
            - Are you sure a story with that id exists?
            - Please check your stories field of your main.js config.
            - Also check the browser console and terminal for error messages.
          `));
      return;
    }
    let { id: storyId, type: viewMode } = entry;
    this.selectionStore.setSelection({ storyId, viewMode }), this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), await this.renderSelection({ persistedArgs: args });
  }
  async onGetProjectAnnotationsChanged({ getProjectAnnotations }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations }), this.selectionStore.selection && this.renderSelection();
  }
  async onStoriesChanged({ importFn, storyIndex }) {
    var _a;
    await super.onStoriesChanged({ importFn, storyIndex }), ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) || this.channel.emit(SET_INDEX, await this.storyStore.getSetIndexPayload()), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(event) {
    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !focusInInput(event)) {
      let { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;
      this.channel.emit(PREVIEW_KEYDOWN, { event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } });
    }
  }
  async onSetCurrentStory(selection) {
    await this.storyStore.initializationPromise, this.selectionStore.setSelection({ viewMode: "story", ...selection }), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(queryParams) {
    this.selectionStore.setQueryParams(queryParams);
  }
  async onUpdateGlobals({ globals }) {
    var _a, _b;
    super.onUpdateGlobals({ globals }), (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) && await ((_b = (_a = this.currentRender).rerender) == null ? void 0 : _b.call(_a));
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    super.onUpdateArgs({ storyId, updatedArgs });
  }
  async onPreloadStories({ ids }) {
    await Promise.allSettled(ids.map((id) => this.storyStore.loadEntry(id)));
  }
  async renderSelection({ persistedArgs } = {}) {
    var _a, _b, _c, _d;
    let { renderToCanvas } = this;
    if (!renderToCanvas)
      throw new Error("Cannot call renderSelection before initialization");
    let { selection } = this.selectionStore;
    if (!selection)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId } = selection, entry;
    try {
      entry = await this.storyStore.storyIdToEntry(storyId);
    } catch (err) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(storyId, err);
      return;
    }
    let storyIdChanged = ((_a = this.currentSelection) == null ? void 0 : _a.storyId) !== storyId, viewModeChanged = ((_b = this.currentRender) == null ? void 0 : _b.type) !== entry.type;
    entry.type === "story" ? this.view.showPreparingStory({ immediate: viewModeChanged }) : this.view.showPreparingDocs({ immediate: viewModeChanged }), ((_c = this.currentRender) == null ? void 0 : _c.isPreparing()) && await this.teardownRender(this.currentRender);
    let render;
    entry.type === "story" ? render = new StoryRender(this.channel, this.storyStore, (...args) => (this.view.showStoryDuringRender(), renderToCanvas(...args)), this.mainStoryCallbacks(storyId), storyId, "story") : isMdxEntry(entry) ? render = new MdxDocsRender(this.channel, this.storyStore, entry) : render = new CsfDocsRender(this.channel, this.storyStore, entry);
    let lastSelection = this.currentSelection;
    this.currentSelection = selection;
    let lastRender = this.currentRender;
    this.currentRender = render;
    try {
      await render.prepare();
    } catch (err) {
      err !== PREPARE_ABORTED && (lastRender && await this.teardownRender(lastRender), this.renderStoryLoadingException(storyId, err));
      return;
    }
    let implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);
    if (persistedArgs && isStoryRender(render)) {
      if (!render.story)
        throw new Error("Render has not been prepared!");
      this.storyStore.args.updateFromPersisted(render.story, persistedArgs);
    }
    if (lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {
      this.currentRender = lastRender, this.channel.emit(STORY_UNCHANGED, storyId), this.view.showMain();
      return;
    }
    if (lastRender && await this.teardownRender(lastRender, { viewModeChanged }), lastSelection && (storyIdChanged || viewModeChanged) && this.channel.emit(STORY_CHANGED, storyId), isStoryRender(render)) {
      if (!render.story)
        throw new Error("Render has not been prepared!");
      let { parameters, initialArgs, argTypes, args } = this.storyStore.getStoryContext(render.story);
      ((_d = scope.FEATURES) == null ? void 0 : _d.storyStoreV7) && this.channel.emit(STORY_PREPARED, { id: storyId, parameters, initialArgs, argTypes, args }), (implementationChanged || persistedArgs) && this.channel.emit(STORY_ARGS_UPDATED, { storyId, args });
    }
    if (isStoryRender(render)) {
      if (!render.story)
        throw new Error("Render has not been prepared!");
      this.storyRenders.push(render), this.currentRender.renderToElement(this.view.prepareForStory(render.story));
    } else
      this.currentRender.renderToElement(this.view.prepareForDocs(), this.renderStoryToElement.bind(this));
  }
  async teardownRender(render, { viewModeChanged = false } = {}) {
    var _a;
    this.storyRenders = this.storyRenders.filter((r) => r !== render), await ((_a = render == null ? void 0 : render.teardown) == null ? void 0 : _a.call(render, { viewModeChanged }));
  }
  async extract(options) {
    var _a;
    if (this.previewEntryError)
      throw this.previewEntryError;
    if (!this.storyStore.projectAnnotations)
      throw new Error(dedent`Failed to initialize Storybook.

      Do you have an error in your \`preview.js\`? Check your Storybook's browser console for errors.`);
    return ((_a = scope.FEATURES) == null ? void 0 : _a.storyStoreV7) && await this.storyStore.cacheAllCSFFiles(), this.storyStore.extract(options);
  }
  mainStoryCallbacks(storyId) {
    return { showMain: () => this.view.showMain(), showError: (err) => this.renderError(storyId, err), showException: (err) => this.renderException(storyId, err) };
  }
  inlineStoryCallbacks(storyId) {
    return { showMain: () => {
    }, showError: (err) => logger.error(`Error rendering docs story (${storyId})`, err), showException: (err) => logger.error(`Error rendering docs story (${storyId})`, err) };
  }
  renderPreviewEntryError(reason, err) {
    super.renderPreviewEntryError(reason, err), this.view.showErrorDisplay(err);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(STORY_MISSING);
  }
  renderStoryLoadingException(storySpecifier, err) {
    logger.error(err), this.view.showErrorDisplay(err), this.channel.emit(STORY_MISSING, storySpecifier);
  }
  renderException(storyId, error) {
    var _a;
    let { name = "Error", message = String(error), stack } = error;
    this.channel.emit(STORY_THREW_EXCEPTION, { name, message, stack }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", storyId }), ((_a = error.message) == null ? void 0 : _a.startsWith("ignoredException")) || (this.view.showErrorDisplay(error), logger.error(`Error rendering story '${storyId}':`), logger.error(error));
  }
  renderError(storyId, { title, description }) {
    logger.error(`Error rendering story ${title}: ${description}`), this.channel.emit(STORY_ERRORED, { title, description }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", storyId }), this.view.showErrorDisplay({ message: title, stack: description });
  }
};
var VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;
var NUMBER_REGEXP = /^-?[0-9]+(\.[0-9]+)?$/;
var HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var COLOR_REGEXP = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var validateArgs = (key = "", value) => key === null || key === "" || !VALIDATION_REGEXP.test(key) ? false : value == null || value instanceof Date || typeof value == "number" || typeof value == "boolean" ? true : typeof value == "string" ? VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value) : Array.isArray(value) ? value.every((v) => validateArgs(key, v)) : (0, import_isPlainObject3.default)(value) ? Object.entries(value).every(([k, v]) => validateArgs(k, v)) : false;
var QS_OPTIONS = { delimiter: ";", allowDots: true, allowSparse: true, decoder(str, defaultDecoder, charset, type) {
  if (type === "value" && str.startsWith("!")) {
    if (str === "!undefined")
      return;
    if (str === "!null")
      return null;
    if (str.startsWith("!date(") && str.endsWith(")"))
      return new Date(str.slice(6, -1));
    if (str.startsWith("!hex(") && str.endsWith(")"))
      return `#${str.slice(5, -1)}`;
    let color = str.slice(1).match(COLOR_REGEXP);
    if (color)
      return str.startsWith("!rgba") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})` : str.startsWith("!hsla") ? `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})` : str.startsWith("!rgb") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;
  }
  return type === "value" && NUMBER_REGEXP.test(str) ? Number(str) : defaultDecoder(str, defaultDecoder, charset);
} };
var parseArgsParam = (argsString) => {
  let parts = argsString.split(";").map((part) => part.replace("=", "~").replace(":", "="));
  return Object.entries(import_qs3.default.parse(parts.join(";"), QS_OPTIONS)).reduce((acc, [key, value]) => validateArgs(key, value) ? Object.assign(acc, { [key]: value }) : (once.warn(dedent`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url
    `), acc), {});
};
var { history, document } = scope;
function pathToId(path) {
  let match = (path || "").match(/^\/story\/(.+)/);
  if (!match)
    throw new Error(`Invalid path '${path}',  must start with '/story/'`);
  return match[1];
}
var getQueryString = ({ selection, extraParams }) => {
  let { search = "" } = document.location, { path, selectedKind, selectedStory, ...rest } = import_qs2.default.parse(search, { ignoreQueryPrefix: true });
  return import_qs2.default.stringify({ ...rest, ...extraParams, ...selection && { id: selection.storyId, viewMode: selection.viewMode } }, { encode: false, addQueryPrefix: true });
};
var setPath = (selection) => {
  if (!selection)
    return;
  let query = getQueryString({ selection }), { hash = "" } = document.location;
  document.title = selection.storyId, history.replaceState({}, "", `${document.location.pathname}${query}${hash}`);
};
var isObject = (val) => val != null && typeof val == "object" && Array.isArray(val) === false;
var getFirstString = (v) => {
  if (v !== void 0) {
    if (typeof v == "string")
      return v;
    if (Array.isArray(v))
      return getFirstString(v[0]);
    if (isObject(v))
      return getFirstString(Object.values(v).filter(Boolean));
  }
};
var getSelectionSpecifierFromPath = () => {
  let query = import_qs2.default.parse(document.location.search, { ignoreQueryPrefix: true }), args = typeof query.args == "string" ? parseArgsParam(query.args) : void 0, globals = typeof query.globals == "string" ? parseArgsParam(query.globals) : void 0, viewMode = getFirstString(query.viewMode);
  (typeof viewMode != "string" || !viewMode.match(/docs|story/)) && (viewMode = "story");
  let path = getFirstString(query.path), storyId = path ? pathToId(path) : getFirstString(query.id);
  return storyId ? { storySpecifier: storyId, args, globals, viewMode } : null;
};
var UrlStore = class {
  constructor() {
    this.selectionSpecifier = getSelectionSpecifierFromPath();
  }
  setSelection(selection) {
    this.selection = selection, setPath(this.selection);
  }
  setQueryParams(queryParams) {
    let query = getQueryString({ extraParams: queryParams }), { hash = "" } = document.location;
    history.replaceState({}, "", `${document.location.pathname}${query}${hash}`);
  }
};
var import_ansi_to_html = __toESM2(require_ansi_to_html());
var { document: document2 } = scope;
var PREPARING_DELAY = 100;
var Mode = ((Mode2) => (Mode2.MAIN = "MAIN", Mode2.NOPREVIEW = "NOPREVIEW", Mode2.PREPARING_STORY = "PREPARING_STORY", Mode2.PREPARING_DOCS = "PREPARING_DOCS", Mode2.ERROR = "ERROR", Mode2))(Mode || {});
var classes = { PREPARING_STORY: "sb-show-preparing-story", PREPARING_DOCS: "sb-show-preparing-docs", MAIN: "sb-show-main", NOPREVIEW: "sb-show-nopreview", ERROR: "sb-show-errordisplay" };
var layoutClassMap = { centered: "sb-main-centered", fullscreen: "sb-main-fullscreen", padded: "sb-main-padded" };
var ansiConverter = new import_ansi_to_html.default({ escapeXML: true });
var WebView = class {
  constructor() {
    this.testing = false;
    let { __SPECIAL_TEST_PARAMETER__ } = import_qs4.default.parse(document2.location.search, { ignoreQueryPrefix: true });
    switch (__SPECIAL_TEST_PARAMETER__) {
      case "preparing-story": {
        this.showPreparingStory(), this.testing = true;
        break;
      }
      case "preparing-docs": {
        this.showPreparingDocs(), this.testing = true;
        break;
      }
      default:
    }
  }
  prepareForStory(story) {
    return this.showStory(), this.applyLayout(story.parameters.layout), document2.documentElement.scrollTop = 0, document2.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return document2.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), this.docsRoot();
  }
  docsRoot() {
    return document2.getElementById("storybook-docs");
  }
  applyLayout(layout = "padded") {
    if (layout === "none") {
      document2.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(layout);
    let layoutClass = layoutClassMap[layout];
    document2.body.classList.remove(this.currentLayoutClass), document2.body.classList.add(layoutClass), this.currentLayoutClass = layoutClass;
  }
  checkIfLayoutExists(layout) {
    layoutClassMap[layout] || logger.warn(dedent`The desired layout: ${layout} is not a valid option.
         The possible options are: ${Object.keys(layoutClassMap).join(", ")}, none.`);
  }
  showMode(mode) {
    clearTimeout(this.preparingTimeout), Object.keys(Mode).forEach((otherMode) => {
      otherMode === mode ? document2.body.classList.add(classes[otherMode]) : document2.body.classList.remove(classes[otherMode]);
    });
  }
  showErrorDisplay({ message = "", stack = "" }) {
    let header = message, detail = stack, parts = message.split(`
`);
    parts.length > 1 && ([header] = parts, detail = parts.slice(1).join(`
`)), document2.getElementById("error-message").innerHTML = ansiConverter.toHtml(header), document2.getElementById("error-stack").innerHTML = ansiConverter.toHtml(detail), this.showMode("ERROR");
  }
  showNoPreview() {
    var _a, _b;
    this.testing || (this.showMode("NOPREVIEW"), (_a = this.storyRoot()) == null ? void 0 : _a.setAttribute("hidden", "true"), (_b = this.docsRoot()) == null ? void 0 : _b.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode("PREPARING_STORY") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_STORY"), PREPARING_DELAY);
  }
  showPreparingDocs({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode("PREPARING_DOCS") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS"), PREPARING_DELAY);
  }
  showMain() {
    this.showMode("MAIN");
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    document2.body.classList.add(classes.MAIN);
  }
};
var PreviewWeb = class extends PreviewWithSelection {
  constructor() {
    super(new UrlStore(), new WebView()), scope.__STORYBOOK_PREVIEW__ = this;
  }
};
var { document: document3 } = scope;

// node_modules/@storybook/preview-api/dist/chunk-YND6GPMW.mjs
function executeLoadable(loadable) {
  let reqs = null;
  Array.isArray(loadable) ? reqs = loadable : loadable.keys && (reqs = [loadable]);
  let exportsMap = /* @__PURE__ */ new Map();
  if (reqs)
    reqs.forEach((req) => {
      req.keys().forEach((filename) => {
        try {
          let fileExports = req(filename);
          exportsMap.set(typeof req.resolve == "function" ? req.resolve(filename) : filename, fileExports);
        } catch (error) {
          let errorString = error.message && error.stack ? `${error.message}
 ${error.stack}` : error.toString();
          logger.error(`Unexpected error while loading ${filename}: ${errorString}`);
        }
      });
    });
  else {
    let exported = loadable();
    Array.isArray(exported) && exported.every((obj) => obj.default != null) ? exportsMap = new Map(exported.map((fileExports, index) => [`exports-map-${index}`, fileExports])) : exported && logger.warn(`Loader function passed to 'configure' should return void or an array of module exports that all contain a 'default' export. Received: ${JSON.stringify(exported)}`);
  }
  return exportsMap;
}
function executeLoadableForChanges(loadable, m) {
  var _a, _b, _c;
  let lastExportsMap = ((_b = (_a = m == null ? void 0 : m.hot) == null ? void 0 : _a.data) == null ? void 0 : _b.lastExportsMap) || /* @__PURE__ */ new Map();
  ((_c = m == null ? void 0 : m.hot) == null ? void 0 : _c.dispose) && (m.hot.accept(), m.hot.dispose((data) => {
    data.lastExportsMap = lastExportsMap;
  }));
  let exportsMap = executeLoadable(loadable), added = /* @__PURE__ */ new Map();
  Array.from(exportsMap.entries()).filter(([, fileExports]) => !!fileExports.default).filter(([fileName, fileExports]) => lastExportsMap.get(fileName) !== fileExports).forEach(([fileName, fileExports]) => added.set(fileName, fileExports));
  let removed = /* @__PURE__ */ new Map();
  return Array.from(lastExportsMap.keys()).filter((fileName) => !exportsMap.has(fileName)).forEach((fileName) => {
    let value = lastExportsMap.get(fileName);
    value && removed.set(fileName, value);
  }), lastExportsMap = exportsMap, { added, removed };
}
var { FEATURES } = scope;
var removedApi = (name) => () => {
  throw new Error(`@storybook/client-api:${name} was removed in storyStoreV7.`);
};
function start(renderToCanvas, { decorateStory: decorateStory2, render } = {}) {
  var _a, _b;
  if (scope && (scope.IS_STORYBOOK = true), FEATURES == null ? void 0 : FEATURES.storyStoreV7)
    return { forceReRender: removedApi("forceReRender"), configure: removedApi("configure"), clientApi: { storiesOf: removedApi("clientApi.storiesOf"), raw: removedApi("raw") } };
  let channel = createChannel({ page: "preview" });
  addons.setChannel(channel);
  let clientApi = ((_a = scope) == null ? void 0 : _a.__STORYBOOK_CLIENT_API__) || new ClientApi(), preview = ((_b = scope) == null ? void 0 : _b.__STORYBOOK_PREVIEW__) || new PreviewWeb(), initialized = false, importFn = (path) => clientApi.importFn(path);
  function onStoriesChanged() {
    let storyIndex = clientApi.getStoryIndex();
    preview.onStoriesChanged({ storyIndex, importFn });
  }
  return clientApi.onImportFnChanged = onStoriesChanged, clientApi.storyStore = preview.storyStore, scope && (scope.__STORYBOOK_CLIENT_API__ = clientApi, scope.__STORYBOOK_ADDONS_CHANNEL__ = channel, scope.__STORYBOOK_PREVIEW__ = preview, scope.__STORYBOOK_STORY_STORE__ = preview.storyStore), { forceReRender: () => channel.emit(FORCE_RE_RENDER), clientApi, configure(framework, loadable, m, disableBackwardCompatibility = true) {
    if (disableBackwardCompatibility)
      throw new Error("unexpected configure() call");
    clientApi.addParameters({ framework });
    let getProjectAnnotations = () => {
      let { added, removed } = executeLoadableForChanges(loadable, m);
      return clientApi._loadAddedExports(), Array.from(added.entries()).forEach(([fileName, fileExports]) => clientApi.facade.addStoriesFromExports(fileName, fileExports)), Array.from(removed.entries()).forEach(([fileName]) => clientApi.facade.clearFilenameExports(fileName)), { render, ...clientApi.facade.projectAnnotations, renderToCanvas, applyDecorators: decorateStory2 };
    };
    initialized ? (getProjectAnnotations(), onStoriesChanged()) : (preview.initialize({ getStoryIndex: () => clientApi.getStoryIndex(), importFn, getProjectAnnotations }), initialized = true);
  } };
}

export {
  dequal,
  sanitizeStoryContextUpdate,
  prepareMeta,
  filterArgTypes,
  composeConfigs,
  Preview,
  DocsContext,
  start
};
//# sourceMappingURL=chunk-BJ3JU4R7.js.map
